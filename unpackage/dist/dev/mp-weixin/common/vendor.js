(global.webpackJsonp = global.webpackJsonp || []).push([['common/vendor'], {

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/Json.js':
  /*! ************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/Json.js ***!
  \*********************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; /* 用户 */
    const userInfo = {
      status: 1,
      data: {
        id: 1,
        mobile: 18888888888,
        nickname: 'Leo yo',
        portrait: 'http://img.61ef.cn/news/201409/28/2014092805595807.jpg',
      },

      msg: '提示',

      /* 首页轮播图 */ };
    const carouselList = [{
      src: '/static/temp/banner3.jpg',
      background: 'rgb(203, 87, 60)',
    },

    {
      src: '/static/temp/banner2.jpg',
      background: 'rgb(205, 215, 218)',
    },

    {
      src: '/static/temp/banner4.jpg',
      background: 'rgb(183, 73, 69)',
    }];


    /* 商品列表 */
    const goodsList = [{
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg',
      image2: 'http://pic.rmb.bdstatic.com/819a044daa66718c2c40a48c1ba971e6.jpeg',
      image3: 'http://img001.hc360.cn/y5/M00/1B/45/wKhQUVYFE0uEZ7zVAAAAAMj3H1w418.jpg',
      title: '古黛妃 短袖t恤女夏装2019新款韩版宽松',
      price: 179,
      sales: 61,
    },

    {
      image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg',
      image2: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1554013048&di=a3dc9fd1406dd7bad7fbb97b5489ec04&imgtype=jpg&er=1&src=http%3A%2F%2Fimg009.hc360.cn%2Fhb%2FnKo44ac2656F831c684507E3Da0E3a26841.jpg',
      image3: 'http://img.zcool.cn/community/017a4e58b4eab6a801219c77084373.jpg',
      title: '潘歌针织连衣裙',
      price: 78,
      sales: 16,
    },

    {
      image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg',
      image2: 'http://m.360buyimg.com/n12/jfs/t247/42/1078640382/162559/3628a0b/53f5ad09N0dd79894.jpg%21q70.jpg',
      image3: 'http://ikids.61kids.com.cn/upload/2018-12-29/1546070626796114.jpg',
      title: '巧谷2019春夏季新品新款女装',
      price: 108.8,
      sales: 5,
    },
    {
      image: 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=756705744,3505936868&fm=11&gp=0.jpg',
      image2: 'http://images.jaadee.com/images/201702/goods_img/30150_d85aed83521.jpg',
      image3: 'http://img13.360buyimg.com/popWaterMark/jfs/t865/120/206320620/138889/dcc94caa/550acedcN613e2a9d.jpg',
      title: '私萱连衣裙',
      price: 265,
      sales: 88,
    },
    {
      image: 'https://img13.360buyimg.com/n8/jfs/t1/30343/20/1029/481370/5c449438Ecb46a15b/2b2adccb6dc742fd.jpg',
      image2: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553418265666&di=d4a7f7eb0ae3c859edeb921641ee1c3a&imgtype=0&src=http%3A%2F%2Fimg003.hc360.cn%2Fy3%2FM02%2FF8%2F9F%2FwKhQh1TuSkGELIlQAAAAAPuLl4M987.jpg',
      image3: 'http://img.ef43.com.cn/product/2016/8/05100204b0c.jpg',
      title: '娇诗茹 ulzzang原宿风学生潮韩版春夏短',
      price: 422,
      sales: 137,
    },
    {
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg',
      image2: 'http://image5.suning.cn/uimg/b2c/newcatentries/0070158827-000000000622091973_2_800x800.jpg',
      image3: 'http://img.61ef.cn/news/201903/20/2019032009251784.jpg',
      title: '古黛妃 短袖t恤女夏装2019新款韩版宽松',
      price: 179,
      sales: 95,
    }];


    /* 购物车 */
    const cartList = [{
      id: 1,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553005139&di=3368549edf9eee769a9bcb3fbbed2504&imgtype=jpg&er=1&src=http%3A%2F%2Fimg002.hc360.cn%2Fy3%2FM01%2F5F%2FDB%2FwKhQh1T7iceEGRdWAAAAADQvqk8733.jpg',
      attr_val: '春装款 L',
      stock: 15,
      title: 'OVBE 长袖风衣',
      price: 278.00,
      number: 1,
    },

    {
      id: 3,
      image: 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2319343996,1107396922&fm=26&gp=0.jpg',
      attr_val: '激光导航 扫拖一体',
      stock: 3,
      title: '科沃斯 Ecovacs 扫地机器人',
      price: 1348.00,
      number: 5,
    },

    {
      id: 4,
      image: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2668268226,1765897385&fm=26&gp=0.jpg',
      attr_val: 'XL',
      stock: 55,
      title: '朵绒菲小西装',
      price: 175.88,
      number: 1,
    },

    {
      id: 5,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552410549432&di=06dd3758053fb6d6362516f30a42d055&imgtype=0&src=http%3A%2F%2Fimgcache.mysodao.com%2Fimg3%2FM0A%2F67%2F42%2FCgAPD1vNSsHNm-TnAAEy61txQb4543_400x400x2.JPG',
      attr_val: '520 #粉红色',
      stock: 15,
      title: '迪奥（Dior）烈艳唇膏',
      price: 1089.00,
      number: 1,
    },

    {
      id: 6,
      image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1031875829,2994442603&fm=26&gp=0.jpg',
      attr_val: '樱花味润手霜 30ml',
      stock: 15,
      title: "欧舒丹（L'OCCITANE）乳木果",
      price: 128,
      number: 1,
    },

    {
      id: 7,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553007107&di=390915aa8a022cf0b03c03340881b0e7&imgtype=jpg&er=1&src=http%3A%2F%2Fimg13.360buyimg.com%2Fn0%2Fjfs%2Ft646%2F285%2F736444951%2F480473%2Faa701c97%2F548176feN10c9ed7b.jpg',
      attr_val: '特级 12个',
      stock: 7,
      title: '新疆阿克苏苹果 特级',
      price: 58.8,
      number: 10,
    },

    {
      id: 8,
      image: 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2319343996,1107396922&fm=26&gp=0.jpg',
      attr_val: '激光导航 扫拖一体',
      stock: 15,
      title: '科沃斯 Ecovacs 扫地机器人',
      price: 1348.00,
      number: 1,
    },

    {
      id: 9,
      image: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2668268226,1765897385&fm=26&gp=0.jpg',
      attr_val: 'XL',
      stock: 55,
      title: '朵绒菲小西装',
      price: 175.88,
      number: 1,
    },

    {
      id: 10,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552410549432&di=06dd3758053fb6d6362516f30a42d055&imgtype=0&src=http%3A%2F%2Fimgcache.mysodao.com%2Fimg3%2FM0A%2F67%2F42%2FCgAPD1vNSsHNm-TnAAEy61txQb4543_400x400x2.JPG',
      attr_val: '520 #粉红色',
      stock: 15,
      title: '迪奥（Dior）烈艳唇膏',
      price: 1089.00,
      number: 1,
    },

    {
      id: 11,
      image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1031875829,2994442603&fm=26&gp=0.jpg',
      attr_val: '樱花味润手霜 30ml',
      stock: 15,
      title: "欧舒丹（L'OCCITANE）乳木果",
      price: 128,
      number: 1,
    },

    {
      id: 12,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553007107&di=390915aa8a022cf0b03c03340881b0e7&imgtype=jpg&er=1&src=http%3A%2F%2Fimg13.360buyimg.com%2Fn0%2Fjfs%2Ft646%2F285%2F736444951%2F480473%2Faa701c97%2F548176feN10c9ed7b.jpg',
      attr_val: '特级 12个',
      stock: 7,
      title: '新疆阿克苏苹果 特级',
      price: 58.8,
      number: 10,
    },

    {
      id: 13,
      image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1552405266625&di=a703f2b2cdb0fe7f3f05f62dd91307ab&imgtype=0&src=http%3A%2F%2Fwww.78.cn%2Fzixun%2Fnews%2Fupload%2F20190214%2F1550114706486250.jpg',
      attr_val: '春装款/m',
      stock: 15,
      title: '女装2019春秋新款',
      price: 420.00,
      number: 1,
    }];


    // 详情展示页面
    const detailData = {
      title: '纯种金毛幼犬活体有血统证书',
      title2: '拆家小能手 你值得拥有',
      favorite: true,
      imgList: [{ src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg' },

        { src: 'http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1309/06/c4/25310541_1378426131583.jpg' },

        { src: 'http://img.pconline.com.cn/images/upload/upc/tx/photoblog/1610/26/c4/28926240_1477451226577_mthumb.jpg' },

        { src: 'http://picture.ik123.com/uploads/allimg/190219/12-1Z219105139.jpg' }],


      episodeList: [
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],

      guessList: [{
        src: 'http://img.52z.com/upload/news/image/20180530/20180530081619_31029.jpg',
        title: '猫眼指甲油',
        title2: '独树一帜的免照灯猫眼指甲',
      },

      {
        src: 'http://m.china-7.net/uploads/14778449362891.jpg',
        title: '创意屋',
        title2: '创意屋形上下双层高低床',
      },

      {
        src: 'http://www.k73.com/up/allimg/130415/22-130415093527.jpg',
        title: 'MissCandy 指甲油',
        title2: '十分适合喜欢素净的妹纸，尽显淡雅的气质',
      },

      {
        src: 'http://img0.imgtn.bdimg.com/it/u=2108933440,2194129200&fm=214&gp=0.jpg	',
        title: 'RMK 2017星空海蓝唇釉',
        title2: '唇釉质地，上唇后很滋润。少女也会心动的蓝色，透明液体形状。',
      }],


      evaList: [{
        src: 'http://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/77c6a7efce1b9d1663174705fbdeb48f8d546486.jpg',
        nickname: 'Ranth Allngal',
        time: '09-20 12:54',
        zan: '54',
        content: '评论不要太苛刻，不管什么产品都会有瑕疵，客服也说了可以退货并且商家承担运费，我觉得至少态度就可以给五星。',
      },

      {
        src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg',
        nickname: 'Ranth Allngal',
        time: '09-20 12:54',
        zan: '54',
        content: '楼上说的好有道理。',
      }],
    };


    const shareList = [{
      type: 1,
      icon: '/static/temp/share_wechat.png',
      text: '微信好友',
    },

    {
      type: 2,
      icon: '/static/temp/share_moment.png',
      text: '朋友圈',
    },

    {
      type: 3,
      icon: '/static/temp/share_qq.png',
      text: 'QQ好友',
    },

    {
      type: 4,
      icon: '/static/temp/share_qqzone.png',
      text: 'QQ空间',
    }];


    const lazyLoadList = [{ src: 'http://img0.imgtn.bdimg.com/it/u=2396068252,4277062836&fm=26&gp=0.jpg' },

      { src: 'http://img.pconline.com.cn/images/upload/upc/tx/itbbs/1309/06/c4/25310541_1378426131583.jpg' },

      { src: 'http://img.pconline.com.cn/images/upload/upc/tx/photoblog/1610/26/c4/28926240_1477451226577_mthumb.jpg' },

      { src: 'http://picture.ik123.com/uploads/allimg/190219/12-1Z219105139.jpg' },

      { src: 'http://img5.imgtn.bdimg.com/it/u=2904900134,438461613&fm=26&gp=0.jpg' },

      { src: 'http://img1.imgtn.bdimg.com/it/u=1690475408,2565370337&fm=26&gp=0.jpg' },

      { src: 'http://img.99114.com/group1/M00/7F/99/wKgGS1kVrPGAe5LmAAU2KrJmb3Q923_600_600.jpg' },

      { src: 'http://img4.imgtn.bdimg.com/it/u=261047209,372231813&fm=26&gp=0.jpg' },

      { src: 'http://i2.17173cdn.com/i7mz64/YWxqaGBf/tu17173com/20150107/eMyVMObjlbcvDEv.jpg' },

      { src: 'http://img008.hc360.cn/m4/M02/E7/87/wKhQ6FSrfU6EfUoyAAAAAITAfyc280.jpg' },

      { src: 'http://pic1.win4000.com/wallpaper/d/5991569950166.jpg' },

      { src: 'http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/6f061d950a7b0208f9fe945e60d9f2d3572cc85e.jpg' },

      { src: 'http://pic41.nipic.com/20140429/18169759_125841756000_2.jpg' },

      { src: 'http://www.k73.com/up/allimg/130415/22-130415093527.jpg' },

      { src: 'http://img.52z.com/upload/news/image/20180530/20180530081619_31029.jpg' },

      { src: 'http://b-ssl.duitang.com/uploads/item/201410/02/20141002111638_tXAzU.jpeg' },

      { src: 'http://img2.ph.126.net/C4JW6f57QWSB21-8jh2UGQ==/1762596304262286698.jpg' },

      { src: 'http://att.bbs.duowan.com/forum/201405/17/190257nzcvkkdg6w2e8226.jpg' },

      { src: 'http://attach.bbs.miui.com/forum/201504/10/223644v3intigyvva0vgym.jpg' },

      { src: 'http://pic1.win4000.com/mobile/3/57888a298d61d.jpg' }];


    const orderList = [{
      time: '2019-04-06 11:37',
      state: 1,
      goodsList: [{ image: 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1553187020783&di=bac9dd78b36fd984502d404d231011c0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201609%2F26%2F20160926173213_s5adi.jpeg' },

        { image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

        { image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' },

        { image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

        { image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' },

        { image: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4031878334,2682695508&fm=11&gp=0.jpg' },

        { image: 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1620020012,789258862&fm=26&gp=0.jpg' }],
    },


    {
      time: '2019-04-06 11:37',
      state: 9,
      goodsList: [{
        title: '古黛妃 短袖t恤女 春夏装2019新款韩版宽松',
        price: 179.5,
        image: 'https://img13.360buyimg.com/n8/jfs/t1/30343/20/1029/481370/5c449438Ecb46a15b/2b2adccb6dc742fd.jpg',
        number: 1,
        attr: '珊瑚粉 M',
      }],
    },


    {
      time: '2019-04-06 11:37',
      state: 1,
      goodsList: [{ image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i2/2120460599/O1CN01LBPS4C1GINkwsOTXS_!!2120460599.jpg_430x430q90.jpg' },

        { image: 'https://img.alicdn.com/imgextra/i2/1069876356/TB2ocTQG4WYBuNjy1zkXXXGGpXa_!!1069876356.jpg_430x430q90.jpg' },

        { image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i4/2120460599/O1CN01YsmgwZ1GINkv38rkn_!!2120460599.jpg_430x430q90.jpg' }],
    },


    {
      time: '2019-04-06 11:37',
      state: 1,
      goodsList: [{
        title: '回力女鞋高帮帆布鞋女学生韩版鞋子女2019潮鞋女鞋新款春季板鞋女',
        price: 69,
        image: 'https://img.alicdn.com/imgextra/i3/2128794607/TB2gzzoc41YBuNjy1zcXXbNcXXa_!!2128794607.jpg_430x430q90.jpg',
        number: 1,
        attr: '白色-高帮 39',
      }],
    },


    {
      time: '2019-04-06 11:37',
      state: 1,
      goodsList: [{ image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i4/3358098495/O1CN01dhYyid2Ccl5MWLDok_!!3358098495.jpg_430x430q90.jpg' },

        { image: 'https://img.alicdn.com/imgextra/https://img.alicdn.com/imgextra/i3/3358098495/O1CN01AWsnFA2Ccl5OzvqsL_!!3358098495.jpg_430x430q90.jpg' }],
    },


    {
      time: '2019-04-06 11:37',
      state: 1,
      goodsList: [{ image: 'https://img.alicdn.com/imgextra/i4/3470687433/O1CN0124mMQOSERr18L1h_!!3470687433.jpg_430x430q90.jpg' },

        { image: 'https://img.alicdn.com/imgextra/i3/2888462616/O1CN01ERra5J1VCAbZaKI5n_!!0-item_pic.jpg_430x430q90.jpg' },

        { image: 'https://gd3.alicdn.com/imgextra/i3/819381730/O1CN01YV4mXj1OeNhQIhQlh_!!819381730.jpg_400x400.jpg' }],
    }];


    const cateList = [{
      id: 1,
      name: '手机数码',
    },

    {
      id: 2,
      name: '礼品鲜花',
    },

    {
      id: 3,
      name: '男装女装',
    },

    {
      id: 4,
      name: '母婴用品',
    },

    {
      id: 5,
      pid: 1,
      name: '手机通讯',
    },

    {
      id: 6,
      pid: 1,
      name: '运营商',
    },

    {
      id: 8,
      pid: 5,
      name: '全面屏手机',
      picture: '/static/temp/cate2.jpg',
    },

    {
      id: 9,
      pid: 5,
      name: '游戏手机',
      picture: '/static/temp/cate3.jpg',
    },

    {
      id: 10,
      pid: 5,
      name: '老人机',
      picture: '/static/temp/cate1.jpg',
    },

    {
      id: 11,
      pid: 5,
      name: '拍照手机',
      picture: '/static/temp/cate4.jpg',
    },

    {
      id: 12,
      pid: 5,
      name: '女性手机',
      picture: '/static/temp/cate5.jpg',
    },

    {
      id: 14,
      pid: 6,
      name: '合约机',
      picture: '/static/temp/cate1.jpg',
    },

    {
      id: 15,
      pid: 6,
      name: '选好卡',
      picture: '/static/temp/cate4.jpg',
    },

    {
      id: 16,
      pid: 6,
      name: '办套餐',
      picture: '/static/temp/cate5.jpg',
    },

    {
      id: 17,
      pid: 2,
      name: '礼品',
    },

    {
      id: 18,
      pid: 2,
      name: '鲜花',
    },

    {
      id: 19,
      pid: 17,
      name: '公益摆件',
      picture: '/static/temp/cate7.jpg',
    },

    {
      id: 20,
      pid: 17,
      name: '创意礼品',
      picture: '/static/temp/cate8.jpg',
    },

    {
      id: 21,
      pid: 18,
      name: '鲜花',
      picture: '/static/temp/cate9.jpg',
    },

    {
      id: 22,
      pid: 18,
      name: '每周一花',
      picture: '/static/temp/cate10.jpg',
    },

    {
      id: 23,
      pid: 18,
      name: '卡通花束',
      picture: '/static/temp/cate11.jpg',
    },

    {
      id: 24,
      pid: 18,
      name: '永生花',
      picture: '/static/temp/cate12.jpg',
    },

    {
      id: 25,
      pid: 3,
      name: '男装',
    },

    {
      id: 26,
      pid: 3,
      name: '女装',
    },

    {
      id: 27,
      pid: 25,
      name: '男士T恤',
      picture: '/static/temp/cate13.jpg',
    },

    {
      id: 28,
      pid: 25,
      name: '男士外套',
      picture: '/static/temp/cate14.jpg',
    },

    {
      id: 29,
      pid: 26,
      name: '裙装',
      picture: '/static/temp/cate15.jpg',
    },

    {
      id: 30,
      pid: 26,
      name: 'T恤',
      picture: '/static/temp/cate16.jpg',
    },

    {
      id: 31,
      pid: 26,
      name: '上装',
      picture: '/static/temp/cate15.jpg',
    },

    {
      id: 32,
      pid: 26,
      name: '下装',
      picture: '/static/temp/cate16.jpg',
    },

    {
      id: 33,
      pid: 4,
      name: '奶粉',
    },

    {
      id: 34,
      pid: 4,
      name: '营养辅食',
    },

    {
      id: 35,
      pid: 4,
      name: '童装',
    },

    {
      id: 39,
      pid: 4,
      name: '喂养用品',
    },

    {
      id: 36,
      pid: 33,
      name: '有机奶粉',
      picture: '/static/temp/cate17.jpg',
    },

    {
      id: 37,
      pid: 34,
      name: '果泥/果汁',
      picture: '/static/temp/cate18.jpg',
    },

    {
      id: 39,
      pid: 34,
      name: '面条/粥',
      picture: '/static/temp/cate20.jpg',
    },

    {
      id: 42,
      pid: 35,
      name: '婴童衣橱',
      picture: '/static/temp/cate19.jpg',
    },

    {
      id: 43,
      pid: 39,
      name: '吸奶器',
      picture: '/static/temp/cate21.jpg',
    },

    {
      id: 44,
      pid: 39,
      name: '儿童餐具',
      picture: '/static/temp/cate22.jpg',
    },

    {
      id: 45,
      pid: 39,
      name: '牙胶安抚',
      picture: '/static/temp/cate23.jpg',
    },

    {
      id: 46,
      pid: 39,
      name: '围兜',
      picture: '/static/temp/cate24.jpg',
    }]; const _default = {
      carouselList,
      cartList,
      detailData,
      lazyLoadList,
      userInfo,
      shareList,
      goodsList,
      orderList,
      cateList,
    }; exports.default = _default;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js':
  /*! ************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js ***!
  \*********************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (createApp) {
      __webpack_require__(/*! uni-pages */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages.json');
      const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js'));
      const _store = _interopRequireDefault(__webpack_require__(/*! ./store */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/index.js'));
      const _App = _interopRequireDefault(__webpack_require__(/*! ./App */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/App.vue'));

      const _request = _interopRequireDefault(__webpack_require__(/*! ./tool/request.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/request.js'));
      const _tool = __webpack_require__(/*! ./tool */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/index.js'); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; let ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter((sym) => Object.getOwnPropertyDescriptor(source, sym).enumerable)); }ownKeys.forEach((key) => { _defineProperty(target, key, source[key]); }); } return target; } function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value, enumerable: true, configurable: true, writable: true,
          });
        } else { obj[key] = value; } return obj;
      } const big_swiper = function big_swiper() { return __webpack_require__.e(/*! import() | components/big_swiper */ 'components/big_swiper').then(__webpack_require__.bind(null, /*! ./components/big_swiper */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/components/big_swiper.vue')); }; // 引入自定义工具函数


      _vue.default.component('bigSwiper', big_swiper);
      _vue.default.config.productionTip = false;
      _vue.default.prototype.$store = _store.default;
      _vue.default.prototype.$api = { msg: _tool.msg, json: _tool.json, prePage: _tool.prePage };
      _vue.default.prototype.$request = _request.default;
      _App.default.mpType = 'app';

      const app = new _vue.default(_objectSpread({},
        _App.default, { store: _store.default }));

      createApp(app).$mount();
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').createApp));
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js?{"page":"pages%2Findex%2Findex"}':
  /*! *********************************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js?{"page":"pages%2Findex%2Findex"} ***!
  \******************************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (createPage) {
      __webpack_require__(/*! uni-pages */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages.json');

      const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js'));
      const _index = _interopRequireDefault(__webpack_require__(/*! ./pages/index/index.vue */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages/index/index.vue')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      createPage(_index.default);
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').createPage));
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js?{"page":"pages%2Fsearch%2Fsearch"}':
  /*! ***********************************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/main.js?{"page":"pages%2Fsearch%2Fsearch"} ***!
  \********************************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (createPage) {
      __webpack_require__(/*! uni-pages */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages.json');

      const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js'));
      const _search = _interopRequireDefault(__webpack_require__(/*! ./pages/search/search.vue */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages/search/search.vue')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
      createPage(_search.default);
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').createPage));
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages.json':
  /*! ***************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/pages.json ***!
  \************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {

    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/index.js':
  /*! *******************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/index.js ***!
  \****************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js'));
    const _vuex = _interopRequireDefault(__webpack_require__(/*! vuex */ './node_modules/vuex/dist/vuex.esm.js'));
    const _store_one = _interopRequireDefault(__webpack_require__(/*! ./store_one */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/index.js')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    _vue.default.use(_vuex.default); const _default = new _vuex.default.Store({
      modules: { // 放入modules
        storeOne: _store_one.default,
      },
    }); exports.default = _default;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/actions/index.js':
  /*! *************************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/actions/index.js ***!
  \************************************************************************************ */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ './node_modules/@babel/runtime/regenerator/index.js')); const _types = __webpack_require__(/*! ../types.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/types.js');
    const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js')); let _SEARCH_INFO$BRAND_IN; function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value, enumerable: true, configurable: true, writable: true,
        });
      } else { obj[key] = value; } return obj;
    } function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var { value } = info; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _asyncToGenerator(fn) { return function () { const self = this; const args = arguments; return new Promise(((resolve, reject) => { const gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err); }_next(undefined); })); }; }
    const $api = _vue.default.prototype; const _default = (_SEARCH_INFO$BRAND_IN = {}, _defineProperty(_SEARCH_INFO$BRAND_IN,

      _types.SEARCH_INFO, (function () {
        const _ref2 = _asyncToGenerator(/* #__PURE__ */_regenerator.default.mark(function _callee(_ref, payload) {
          let commit; let
            result; return _regenerator.default.wrap((_context) => {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0: commit = _ref.commit; _context.next = 3; return (
                  $api.$request.POST(payload)); case 3: result = _context.sent;
                  commit(_types.SEARCH_INFO, result); return _context.abrupt('return',
                    result); case 6: case 'end': return _context.stop();
              }
            }
          }, _callee, this);
        })); return function (_x, _x2) { return _ref2.apply(this, arguments); };
      }())), _defineProperty(_SEARCH_INFO$BRAND_IN,

      _types.BRAND_INFO, (function () {
        const _ref4 = _asyncToGenerator(/* #__PURE__ */_regenerator.default.mark(function _callee2(_ref3, payload) {
          let commit; let
            result; return _regenerator.default.wrap((_context2) => {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0: commit = _ref3.commit; _context2.next = 3; return (
                  $api.$request.POST(payload)); case 3: result = _context2.sent;
                  commit(_types.BRAND_INFO, result); return _context2.abrupt('return',
                    result); case 6: case 'end': return _context2.stop();
              }
            }
          }, _callee2, this);
        })); return function (_x3, _x4) { return _ref4.apply(this, arguments); };
      }())), _defineProperty(_SEARCH_INFO$BRAND_IN,

      _types.SORT_LIST, (function () {
        const _ref6 = _asyncToGenerator(/* #__PURE__ */_regenerator.default.mark(function _callee3(_ref5, payload) {
          let commit; let
            result; return _regenerator.default.wrap((_context3) => {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0: commit = _ref5.commit; _context3.next = 3; return (
                  $api.$request.POST(payload)); case 3: result = _context3.sent;
                  commit(_types.SORT_LIST, result); return _context3.abrupt('return',
                    result); case 6: case 'end': return _context3.stop();
              }
            }
          }, _callee3, this);
        })); return function (_x5, _x6) { return _ref6.apply(this, arguments); };
      }())), _SEARCH_INFO$BRAND_IN); exports.default = _default;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/getters/index.js':
  /*! *************************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/getters/index.js ***!
  \************************************************************************************ */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {

    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/index.js':
  /*! *****************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/index.js ***!
  \**************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _index = _interopRequireDefault(__webpack_require__(/*! ./state/index.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/state/index.js'));
    const _index2 = _interopRequireDefault(__webpack_require__(/*! ./mutations/index.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/mutations/index.js'));
    const _index3 = _interopRequireDefault(__webpack_require__(/*! ./actions/index.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/actions/index.js'));
    const _index4 = _interopRequireDefault(__webpack_require__(/*! ./getters/index.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/getters/index.js')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _objectSpread(target) { for (let i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; let ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter((sym) => Object.getOwnPropertyDescriptor(source, sym).enumerable)); }ownKeys.forEach((key) => { _defineProperty(target, key, source[key]); }); } return target; } function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value, enumerable: true, configurable: true, writable: true,
        });
      } else { obj[key] = value; } return obj;
    } const _default = {
      namespaced: true,
      state: _objectSpread({},
        _index.default),

      mutations: _objectSpread({},
        _index2.default),

      actions: _objectSpread({},
        _index3.default),

      getters: _objectSpread({},
        _index4.default),
    }; exports.default = _default;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/mutations/index.js':
  /*! ***************************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/mutations/index.js ***!
  \************************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (uni) {
      Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _types = __webpack_require__(/*! ../types.js */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/types.js'); let _LOGOUT$LOGOUT$ADD$SE; function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value, enumerable: true, configurable: true, writable: true,
          });
        } else { obj[key] = value; } return obj;
      } const _default = (_LOGOUT$LOGOUT$ADD$SE = {}, _defineProperty(_LOGOUT$LOGOUT$ADD$SE,

        _types.LOGOUT, (state, provider) => {
          state.hasLogin = true;
          state.userInfo = provider;
          uni.setStorage({ // 缓存用户登陆状态
            key: 'userInfo',
            data: provider,
          });

          console.log(state.userInfo);
        }), _defineProperty(_LOGOUT$LOGOUT$ADD$SE,
        _types.LOGOUT, (state) => {
          state.hasLogin = false;
          state.userInfo = {};
          uni.removeStorage({ key: 'userInfo' });
        }), _defineProperty(_LOGOUT$LOGOUT$ADD$SE,
        _types.ADD, (state, payload) => {
          state.num += payload.b;
        }), _defineProperty(_LOGOUT$LOGOUT$ADD$SE,
        _types.SEARCH_INFO, (state, payload) => {
          state.search_info = payload.data;
        }), _defineProperty(_LOGOUT$LOGOUT$ADD$SE,
        _types.BRAND_INFO, (state, payload) => {
          state.brand_info = payload.data;
        }), _defineProperty(_LOGOUT$LOGOUT$ADD$SE,
        _types.SORT_LIST, (state, payload) => {
          state.sort_info = payload.data;
        }), _LOGOUT$LOGOUT$ADD$SE); exports.default = _default;
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').default));
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/state/index.js':
  /*! ***********************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/state/index.js ***!
  \********************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _default = {
      hasLogin: false,
      userInfo: {},
      num: 0,
      search_info: null,
      brand_info: null,
      sort_info: null,
    }; exports.default = _default;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/types.js':
  /*! *****************************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/store/store_one/types.js ***!
  \**************************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.SORT_LIST = exports.BRAND_INFO = exports.SEARCH_INFO = exports.ADD = exports.LOGOUT = exports.LOGIN = void 0; const LOGIN = 'LOGIN'; exports.LOGIN = LOGIN;
    const LOGOUT = 'LOGOUT'; exports.LOGOUT = LOGOUT;
    const ADD = 'ADD'; exports.ADD = ADD;
    const SEARCH_INFO = 'SEARCH_INFO'; exports.SEARCH_INFO = SEARCH_INFO;
    const BRAND_INFO = 'BRAND_INFO'; exports.BRAND_INFO = BRAND_INFO;
    const SORT_LIST = 'SORT_LIST'; exports.SORT_LIST = SORT_LIST;
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/index.js':
  /*! ******************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/index.js ***!
  \***************************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (uni) {
      Object.defineProperty(exports, '__esModule', { value: true }); exports.prePage = exports.json = exports.msg = void 0; const _Json = _interopRequireDefault(__webpack_require__(/*! ../Json */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/Json.js')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } // 测试时用的数据
      // 调用消息提醒
      const msg = function msg(title) {
        const duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1500; const mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; const icon = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';
        if (Boolean(title) === false) {
          return;
        }
        uni.showToast({
          title,
          duration,
          mask,
          icon,
        });
      };
      // 模拟异步请求数据
      exports.msg = msg; const json = function json(type) {
        return new Promise(((resolve) => {
          setTimeout(() => {
            resolve(_Json.default[type]);
          }, 500);
        }));
      };
      // 关于页面的
      exports.json = json; const prePage = function prePage() {
        const pages = getCurrentPages();
        const prePage = pages[pages.length - 2];


        return prePage.$vm;
      }; exports.prePage = prePage;
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').default));
    /** */ }),

  /** */ '../../../../../../Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/request.js':
  /*! ********************************************************************!*\
  !*** /Users/Rope/Desktop/mix-mall/mix-mall 电商项目模版/tool/request.js ***!
  \******************************************************************* */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /* WEBPACK VAR INJECTION */(function (uni) {
      Object.defineProperty(exports, '__esModule', { value: true }); exports.default = void 0; const _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ './node_modules/@babel/runtime/regenerator/index.js')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } function _iterableToArrayLimit(arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i.return != null) _i.return(); } finally { if (_d) throw _e; } } return _arr; } function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var { value } = info; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _asyncToGenerator(fn) { return function () { const self = this; const args = arguments; return new Promise(((resolve, reject) => { const gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err); }_next(undefined); })); }; } // var url_prefix = "/api";//测试环境
      const url_prefix = 'http://127.0.0.1:8888'; // 线上环境
      const _default = {
        GET: (function () {
          const _GET = _asyncToGenerator(/* #__PURE__ */_regenerator.default.mark(function _callee(data_obj) {
            let _ref; let _ref2; let error; let
              res; return _regenerator.default.wrap((_context) => {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0: _context.next = 2; return (
                    uni.request({
                      url: url_prefix + data_obj.url,
                      method: 'GET',
                    })); case 2: _ref = _context.sent; _ref2 = _slicedToArray(_ref, 2); error = _ref2[0]; res = _ref2[1]; return _context.abrupt('return',

                    res.data); case 7: case 'end': return _context.stop();
                }
              }
            }, _callee, this);
          })); function GET(_x) { return _GET.apply(this, arguments); } return GET;
        }()),

        POST: (function () {
          const _POST = _asyncToGenerator(/* #__PURE__ */_regenerator.default.mark(function _callee2(data_obj) {
            let _ref3; let _ref4; let error; let
              res; return _regenerator.default.wrap((_context2) => {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0: _context2.next = 2; return (
                    uni.request({
                      url: url_prefix + data_obj.url,
                      method: 'POST',
                      data: data_obj.data,
                    })); case 2: _ref3 = _context2.sent; _ref4 = _slicedToArray(_ref3, 2); error = _ref4[0]; res = _ref4[1]; return _context2.abrupt('return',

                    res.data); case 7: case 'end': return _context2.stop();
                }
              }
            }, _callee2, this);
          })); function POST(_x2) { return _POST.apply(this, arguments); } return POST;
        }()),
      }; exports.default = _default;
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js').default));
    /** */ }),

  /** */ './node_modules/@babel/runtime/regenerator/index.js':
  /*! **********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \********************************************************* */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    module.exports = __webpack_require__(/*! regenerator-runtime */ './node_modules/regenerator-runtime/runtime-module.js');
    /** */ }),

  /** */ './node_modules/@dcloudio/uni-mp-weixin/dist/index.js':
  /*! ************************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js ***!
  \*********************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    Object.defineProperty(exports, '__esModule', { value: true }); exports.createApp = createApp; exports.createPage = createPage; exports.createComponent = createComponent; exports.default = void 0; const _vue = _interopRequireDefault(__webpack_require__(/*! vue */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js')); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } function _iterableToArrayLimit(arr, i) { const _arr = []; let _n = true; let _d = false; let _e; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i.return != null) _i.return(); } finally { if (_d) throw _e; } } return _arr; } function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value, enumerable: true, configurable: true, writable: true,
        });
      } else { obj[key] = value; } return obj;
    }

    const _toString = Object.prototype.toString;
    const { hasOwnProperty } = Object.prototype;

    function isFn(fn) {
      return typeof fn === 'function';
    }

    function isStr(str) {
      return typeof str === 'string';
    }

    function isPlainObject(obj) {
      return _toString.call(obj) === '[object Object]';
    }

    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }

    function noop() {}

    /**
                    * Create a cached version of a pure function.
                    */
    function cached(fn) {
      const cache = Object.create(null);
      return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    }

    /**
   * Camelize a hyphen-delimited string.
   */
    const camelizeRE = /-(\w)/g;
    const camelize = cached((str) => str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : '')));

    const SYNC_API_RE = /^\$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64/;

    const CONTEXT_API_RE = /^create|Manager$/;

    const CALLBACK_API_RE = /^on/;

    function isContextApi(name) {
      return CONTEXT_API_RE.test(name);
    }
    function isSyncApi(name) {
      return SYNC_API_RE.test(name);
    }

    function isCallbackApi(name) {
      return CALLBACK_API_RE.test(name);
    }

    function handlePromise(promise) {
      return promise.then((data) => [null, data])
        .catch((err) => [err]);
    }

    function shouldPromise(name) {
      if (
        isContextApi(name)
  || isSyncApi(name)
  || isCallbackApi(name)) {
        return false;
      }
      return true;
    }

    function promisify(name, api) {
      if (!shouldPromise(name)) {
        return api;
      }
      return function promiseApi() {
        const options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) { params[_key - 1] = arguments[_key]; }
        if (isFn(options.success) || isFn(options.fail) || isFn(options.complete)) {
          return api.apply(void 0, [options].concat(params));
        }
        return handlePromise(new Promise(((resolve, reject) => {
          api.apply(void 0, [{
            ...options,
            success: resolve,
            fail: reject,
          }].concat(
            params,
          ));
          /* eslint-disable no-extend-native */
          if (!Promise.prototype.finally) {
            Promise.prototype.finally = function (callback) {
              const promise = this.constructor;
              return this.then(
                (value) => promise.resolve(callback()).then(() => value),
                (reason) => promise.resolve(callback()).then(() => {
                  throw reason;
                }),
              );
            };
          }
        })));
      };
    }

    const EPS = 1e-4;
    const BASE_DEVICE_WIDTH = 750;
    let isIOS = false;
    let deviceWidth = 0;
    let deviceDPR = 0;

    function checkDeviceWidth() {
      const _wx$getSystemInfoSync = wx.getSystemInfoSync(); const { platform } = _wx$getSystemInfoSync; const { pixelRatio } = _wx$getSystemInfoSync; const { windowWidth } = _wx$getSystemInfoSync; // uni=>wx runtime 编译目标是 uni 对象，内部不允许直接使用 uni

      deviceWidth = windowWidth;
      deviceDPR = pixelRatio;
      isIOS = platform === 'ios';
    }

    function upx2px(number, newDeviceWidth) {
      if (deviceWidth === 0) {
        checkDeviceWidth();
      }

      number = Number(number);
      if (number === 0) {
        return 0;
      }
      let result = number / BASE_DEVICE_WIDTH * (newDeviceWidth || deviceWidth);
      if (result < 0) {
        result = -result;
      }
      result = Math.floor(result + EPS);
      if (result === 0) {
        if (deviceDPR === 1 || !isIOS) {
          return 1;
        }
        return 0.5;
      }
      return number < 0 ? -result : result;
    }

    const previewImage = {
      args: function args(fromArgs) {
        let currentIndex = parseInt(fromArgs.current);
        if (isNaN(currentIndex)) {
          return;
        }
        const { urls } = fromArgs;
        if (!Array.isArray(urls)) {
          return;
        }
        const len = urls.length;
        if (!len) {
          return;
        }
        if (currentIndex < 0) {
          currentIndex = 0;
        } else if (currentIndex >= len) {
          currentIndex = len - 1;
        }
        if (currentIndex > 0) {
          fromArgs.current = urls[currentIndex];
          fromArgs.urls = urls.filter(
            (item, index) => (index < currentIndex ? item !== urls[currentIndex] : true),
          );
        } else {
          fromArgs.current = urls[0];
        }
        return {
          indicator: false,
          loop: false,
        };
      },
    };


    const protocols = { previewImage };

    const todos = [];
    const canIUses = [];

    const CALLBACKS = ['success', 'fail', 'cancel', 'complete'];

    function processCallback(methodName, method, returnValue) {
      return function (res) {
        return method(processReturnValue(methodName, res, returnValue));
      };
    }

    function processArgs(methodName, fromArgs) {
      let argsOption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; const returnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}; const keepFromArgs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      if (isPlainObject(fromArgs)) { // 一般 api 的参数解析
        const toArgs = keepFromArgs === true ? fromArgs : {}; // returnValue 为 false 时，说明是格式化返回值，直接在返回值对象上修改赋值
        if (isFn(argsOption)) {
          argsOption = argsOption(fromArgs, toArgs) || {};
        }
        for (const key in fromArgs) {
          if (hasOwn(argsOption, key)) {
            let keyOption = argsOption[key];
            if (isFn(keyOption)) {
              keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
            }
            if (!keyOption) { // 不支持的参数
              console.warn('\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F '.concat(methodName, '\u6682\u4E0D\u652F\u6301').concat(key));
            } else if (isStr(keyOption)) { // 重写参数 key
              toArgs[keyOption] = fromArgs[key];
            } else if (isPlainObject(keyOption)) { // {name:newName,value:value}可重新指定参数 key:value
              toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
            }
          } else if (CALLBACKS.indexOf(key) !== -1) {
            toArgs[key] = processCallback(methodName, fromArgs[key], returnValue);
          } else if (!keepFromArgs) {
            toArgs[key] = fromArgs[key];
          }
        }
        return toArgs;
      } if (isFn(fromArgs)) {
        fromArgs = processCallback(methodName, fromArgs, returnValue);
      }
      return fromArgs;
    }

    function processReturnValue(methodName, res, returnValue) {
      const keepReturnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (isFn(protocols.returnValue)) { // 处理通用 returnValue
        res = protocols.returnValue(methodName, res);
      }
      return processArgs(methodName, res, returnValue, {}, keepReturnValue);
    }

    function wrapper(methodName, method) {
      if (hasOwn(protocols, methodName)) {
        const protocol = protocols[methodName];
        if (!protocol) { // 暂不支持的 api
          return function () {
            console.error('\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F \u6682\u4E0D\u652F\u6301'.concat(methodName));
          };
        }
        return function (arg1, arg2) { // 目前 api 最多两个参数
          let options = protocol;
          if (isFn(protocol)) {
            options = protocol(arg1);
          }

          arg1 = processArgs(methodName, arg1, options.args, options.returnValue);

          const args = [arg1];
          if (typeof arg2 !== 'undefined') {
            args.push(arg2);
          }
          const returnValue = wx[options.name || methodName].apply(wx, args);
          if (isSyncApi(methodName)) { // 同步 api
            return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
          }
          return returnValue;
        };
      }
      return method;
    }

    const todoApis = Object.create(null);

    const TODOS = [
      'subscribePush',
      'unsubscribePush',
      'onPush',
      'offPush',
      'share'];


    function createTodoApi(name) {
      return function todoApi(_ref) {
        const { fail } = _ref;
        const { complete } = _ref;
        const res = { errMsg: ''.concat(name, ':fail:\u6682\u4E0D\u652F\u6301 ').concat(name, ' \u65B9\u6CD5') };

        isFn(fail) && fail(res);
        isFn(complete) && complete(res);
      };
    }

    TODOS.forEach((name) => {
      todoApis[name] = createTodoApi(name);
    });

    const providers = {
      oauth: ['weixin'],
      share: ['weixin'],
      payment: ['wxpay'],
      push: ['weixin'],
    };


    function getProvider(_ref2) {
      const { service } = _ref2;
      const { success } = _ref2; const { fail } = _ref2;
      const { complete } = _ref2;
      let res = false;
      if (providers[service]) {
        res = {
          errMsg: 'getProvider:ok',
          service,
          provider: providers[service],
        };

        isFn(success) && success(res);
      } else {
        res = { errMsg: `getProvider:fail:服务[${service}]不存在` };

        isFn(fail) && fail(res);
      }
      isFn(complete) && complete(res);
    }

    const extraApi = /* #__PURE__ */Object.freeze({ getProvider });


    const getEmitter = (function () {
      if (typeof getUniEmitter === 'function') {
        /* eslint-disable no-undef */
        return getUniEmitter;
      }
      let Emitter;
      return function getUniEmitter() {
        if (!Emitter) {
          Emitter = new _vue.default();
        }
        return Emitter;
      };
    }());

    function apply(ctx, method, args) {
      return ctx[method].apply(ctx, args);
    }

    function $on() {
      return apply(getEmitter(), '$on', Array.prototype.slice.call(arguments));
    }
    function $off() {
      return apply(getEmitter(), '$off', Array.prototype.slice.call(arguments));
    }
    function $once() {
      return apply(getEmitter(), '$once', Array.prototype.slice.call(arguments));
    }
    function $emit() {
      return apply(getEmitter(), '$emit', Array.prototype.slice.call(arguments));
    }


    const eventApi = /* #__PURE__ */Object.freeze({
      $on,
      $off,
      $once,
      $emit,
    });


    const api = /* #__PURE__ */Object.freeze({});


    const MPPage = Page;
    const MPComponent = Component;

    const customizeRE = /:/g;

    const customize = cached((str) => camelize(str.replace(customizeRE, '-')));

    function initTriggerEvent(mpInstance) {
      {
        if (!wx.canIUse('nextTick')) {
          return;
        }
      }
      const oldTriggerEvent = mpInstance.triggerEvent;
      mpInstance.triggerEvent = function (event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) { args[_key2 - 1] = arguments[_key2]; }
        return oldTriggerEvent.apply(mpInstance, [customize(event)].concat(args));
      };
    }

    function initHook(name, options) {
      const oldHook = options[name];
      if (!oldHook) {
        options[name] = function () {
          initTriggerEvent(this);
        };
      } else {
        options[name] = function () {
          initTriggerEvent(this); for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) { args[_key3] = arguments[_key3]; }
          return oldHook.apply(this, args);
        };
      }
    }

    Page = function Page() {
      const options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      initHook('onLoad', options);
      return MPPage(options);
    };

    Component = function Component() {
      const options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      initHook('created', options);
      return MPComponent(options);
    };

    const PAGE_EVENT_HOOKS = [
      'onPullDownRefresh',
      'onReachBottom',
      'onShareAppMessage',
      'onPageScroll',
      'onResize',
      'onTabItemTap'];


    function initMocks(vm, mocks) {
      const mpInstance = vm.$mp[vm.mpType];
      mocks.forEach((mock) => {
        if (hasOwn(mpInstance, mock)) {
          vm[mock] = mpInstance[mock];
        }
      });
    }

    function initHooks(mpOptions, hooks) {
      hooks.forEach((hook) => {
        mpOptions[hook] = function (args) {
          return this.$vm && this.$vm.__call_hook(hook, args);
        };
      });
    }

    function initVueComponent(Vue$$1, vueOptions) {
      vueOptions = vueOptions.default || vueOptions;
      let VueComponent;
      if (isFn(vueOptions)) {
        VueComponent = vueOptions;
        vueOptions = VueComponent.extendOptions;
      } else {
        VueComponent = Vue$$1.extend(vueOptions);
      }
      return [VueComponent, vueOptions];
    }

    function initSlots(vm, vueSlots) {
      if (Array.isArray(vueSlots) && vueSlots.length) {
        const $slots = Object.create(null);
        vueSlots.forEach((slotName) => {
          $slots[slotName] = true;
        });
        vm.$scopedSlots = vm.$slots = $slots;
      }
    }

    function initVueIds(vueIds, mpInstance) {
      vueIds = (vueIds || '').split(',');
      const len = vueIds.length;

      if (len === 1) {
        mpInstance._$vueId = vueIds[0];
      } else if (len === 2) {
        mpInstance._$vueId = vueIds[0];
        mpInstance._$vuePid = vueIds[1];
      }
    }

    function initData(vueOptions, context) {
      let data = vueOptions.data || {};
      const methods = vueOptions.methods || {};

      if (typeof data === 'function') {
        try {
          data = data.call(context); // 支持 Vue.prototype 上挂的数据
        } catch (e) {
          if (Object({ NODE_ENV: 'development', VUE_APP_PLATFORM: 'mp-weixin', BASE_URL: '/' }).VUE_APP_DEBUG) {
            console.warn('根据 Vue 的 data 函数初始化小程序 data 失败，请尽量确保 data 函数中不访问 vm 对象，否则可能影响首次数据渲染速度。', data);
          }
        }
      } else {
        try {
          // 对 data 格式化
          data = JSON.parse(JSON.stringify(data));
        } catch (e) {}
      }

      if (!isPlainObject(data)) {
        data = {};
      }

      Object.keys(methods).forEach((methodName) => {
        if (context.__lifecycle_hooks__.indexOf(methodName) === -1 && !hasOwn(data, methodName)) {
          data[methodName] = methods[methodName];
        }
      });

      return data;
    }

    const PROP_TYPES = [String, Number, Boolean, Object, Array, null];

    function createObserver(name) {
      return function observer(newVal, oldVal) {
        if (this.$vm) {
          this.$vm[name] = newVal; // 为了触发其他非 render watcher
        }
      };
    }

    function initBehaviors(vueOptions, initBehavior) {
      const vueBehaviors = vueOptions.behaviors;
      const vueExtends = vueOptions.extends;
      const vueMixins = vueOptions.mixins;

      let vueProps = vueOptions.props;

      if (!vueProps) {
        vueOptions.props = vueProps = [];
      }

      const behaviors = [];
      if (Array.isArray(vueBehaviors)) {
        vueBehaviors.forEach((behavior) => {
          behaviors.push(behavior.replace('uni://', 'wx'.concat('://')));
          if (behavior === 'uni://form-field') {
            if (Array.isArray(vueProps)) {
              vueProps.push('name');
              vueProps.push('value');
            } else {
              vueProps.name = String;
              vueProps.value = null;
            }
          }
        });
      }
      if (isPlainObject(vueExtends) && vueExtends.props) {
        behaviors.push(
          initBehavior({ properties: initProperties(vueExtends.props, true) }),
        );
      }
      if (Array.isArray(vueMixins)) {
        vueMixins.forEach((vueMixin) => {
          if (isPlainObject(vueMixin) && vueMixin.props) {
            behaviors.push(
              initBehavior({ properties: initProperties(vueMixin.props, true) }),
            );
          }
        });
      }
      return behaviors;
    }

    function parsePropType(key, type, defaultValue, file) {
      // [String]=>String
      if (Array.isArray(type) && type.length === 1) {
        return type[0];
      }
      return type;
    }

    function initProperties(props) {
      const isBehavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; const file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      const properties = {};
      if (!isBehavior) {
        properties.vueId = {
          type: String,
          value: '',
        };

        properties.vueSlots = { // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots
          type: null,
          value: [],
          observer: function observer(newVal, oldVal) {
            const $slots = Object.create(null);
            newVal.forEach((slotName) => {
              $slots[slotName] = true;
            });
            this.setData({ $slots });
          },
        };
      }
      if (Array.isArray(props)) { // ['title']
        props.forEach((key) => {
          properties[key] = {
            type: null,
            observer: createObserver(key),
          };
        });
      } else if (isPlainObject(props)) { // {title:{type:String,default:''},content:String}
        Object.keys(props).forEach((key) => {
          const opts = props[key];
          if (isPlainObject(opts)) { // title:{type:String,default:''}
            let value = opts.default;
            if (isFn(value)) {
              value = value();
            }

            opts.type = parsePropType(key, opts.type, value, file);

            properties[key] = {
              type: PROP_TYPES.indexOf(opts.type) !== -1 ? opts.type : null,
              value,
              observer: createObserver(key),
            };
          } else { // content:String
            const type = parsePropType(key, opts, null, file);
            properties[key] = {
              type: PROP_TYPES.indexOf(type) !== -1 ? type : null,
              observer: createObserver(key),
            };
          }
        });
      }
      return properties;
    }

    function wrapper$1(event) {
      // TODO 又得兼容 mpvue 的 mp 对象
      try {
        event.mp = JSON.parse(JSON.stringify(event));
      } catch (e) {}

      event.stopPropagation = noop;
      event.preventDefault = noop;

      event.target = event.target || {};

      if (!hasOwn(event, 'detail')) {
        event.detail = {};
      }

      if (isPlainObject(event.detail)) {
        event.target = { ...event.target, ...event.detail };
      }

      return event;
    }

    function getExtraValue(vm, dataPathsArray) {
      let context = vm;
      dataPathsArray.forEach((dataPathArray) => {
        const dataPath = dataPathArray[0];
        const value = dataPathArray[2];
        if (dataPath || typeof value !== 'undefined') { // ['','',index,'disable']
          const propPath = dataPathArray[1];
          const valuePath = dataPathArray[3];

          const vFor = dataPath ? vm.__get_value(dataPath, context) : context;

          if (Number.isInteger(vFor)) {
            context = value;
          } else if (!propPath) {
            context = vFor[value];
          } else if (Array.isArray(vFor)) {
            context = vFor.find((vForItem) => vm.__get_value(propPath, vForItem) === value);
          } else if (isPlainObject(vFor)) {
            context = Object.keys(vFor).find((vForKey) => vm.__get_value(propPath, vFor[vForKey]) === value);
          } else {
            console.error('v-for 暂不支持循环数据：', vFor);
          }

          if (valuePath) {
            context = vm.__get_value(valuePath, context);
          }
        }
      });
      return context;
    }

    function processEventExtra(vm, extra, event) {
      const extraObj = {};

      if (Array.isArray(extra) && extra.length) {
        /**
                                                  *[
                                                  *    ['data.items', 'data.id', item.data.id],
                                                  *    ['metas', 'id', meta.id]
                                                  *],
                                                  *[
                                                  *    ['data.items', 'data.id', item.data.id],
                                                  *    ['metas', 'id', meta.id]
                                                  *],
                                                  *'test'
                                                  */
        extra.forEach((dataPath, index) => {
          if (typeof dataPath === 'string') {
            if (!dataPath) { // model,prop.sync
              extraObj[`$${index}`] = vm;
            } else if (dataPath === '$event') { // $event
              extraObj[`$${index}`] = event;
            } else if (dataPath.indexOf('$event.') === 0) { // $event.target.value
              extraObj[`$${index}`] = vm.__get_value(dataPath.replace('$event.', ''), event);
            } else {
              extraObj[`$${index}`] = vm.__get_value(dataPath);
            }
          } else {
            extraObj[`$${index}`] = getExtraValue(vm, dataPath);
          }
        });
      }

      return extraObj;
    }

    function getObjByArray(arr) {
      const obj = {};
      for (let i = 1; i < arr.length; i++) {
        const element = arr[i];
        obj[element[0]] = element[1];
      }
      return obj;
    }

    function processEventArgs(vm, event) {
      const args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []; const extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; const isCustom = arguments.length > 4 ? arguments[4] : undefined; const methodName = arguments.length > 5 ? arguments[5] : undefined;
      let isCustomMPEvent = false; // wxcomponent 组件，传递原始 event 对象
      if (isCustom) { // 自定义事件
        isCustomMPEvent = event.currentTarget
    && event.currentTarget.dataset
    && event.currentTarget.dataset.comType === 'wx';
        if (!args.length) { // 无参数，直接传入 event 或 detail 数组
          if (isCustomMPEvent) {
            return [event];
          }
          return event.detail.__args__ || event.detail;
        }
      }

      const extraObj = processEventExtra(vm, extra, event);

      const ret = [];
      args.forEach((arg) => {
        if (arg === '$event') {
          if (methodName === '__set_model' && !isCustom) { // input v-model value
            ret.push(event.target.value);
          } else if (isCustom && !isCustomMPEvent) {
            ret.push(event.detail.__args__[0]);
          } else { // wxcomponent 组件或内置组件
            ret.push(event);
          }
        } else if (Array.isArray(arg) && arg[0] === 'o') {
          ret.push(getObjByArray(arg));
        } else if (typeof arg === 'string' && hasOwn(extraObj, arg)) {
          ret.push(extraObj[arg]);
        } else {
          ret.push(arg);
        }
      });

      return ret;
    }

    const ONCE = '~';
    const CUSTOM = '^';

    function isMatchEventType(eventType, optType) {
      return eventType === optType

  || optType === 'regionchange' && (

    eventType === 'begin'
  || eventType === 'end');
    }

    function handleEvent(event) {
      const _this = this;
      event = wrapper$1(event);

      // [['tap',[['handle',[1,2,a]],['handle1',[1,2,a]]]]]
      const { eventOpts } = (event.currentTarget || event.target).dataset;
      if (!eventOpts) {
        return console.warn('\u4E8B\u4EF6\u4FE1\u606F\u4E0D\u5B58\u5728');
      }

      // [['handle',[1,2,a]],['handle1',[1,2,a]]]
      const eventType = event.type;
      eventOpts.forEach((eventOpt) => {
        let type = eventOpt[0];
        const eventsArray = eventOpt[1];

        const isCustom = type.charAt(0) === CUSTOM;
        type = isCustom ? type.slice(1) : type;
        const isOnce = type.charAt(0) === ONCE;
        type = isOnce ? type.slice(1) : type;

        if (eventsArray && isMatchEventType(eventType, type)) {
          eventsArray.forEach((eventArray) => {
            const methodName = eventArray[0];
            if (methodName) {
              let handlerCtx = _this.$vm;
              if (
                handlerCtx.$options.generic
          && handlerCtx.$parent
          && handlerCtx.$parent.$parent) { // mp-weixin,mp-toutiao 抽象节点模拟 scoped slots
                handlerCtx = handlerCtx.$parent.$parent;
              }
              const handler = handlerCtx[methodName];
              if (!isFn(handler)) {
                throw new Error(' _vm.'.concat(methodName, ' is not a function'));
              }
              if (isOnce) {
                if (handler.once) {
                  return;
                }
                handler.once = true;
              }
              handler.apply(handlerCtx, processEventArgs(
                _this.$vm,
                event,
                eventArray[1],
                eventArray[2],
                isCustom,
                methodName,
              ));
            }
          });
        }
      });
    }

    const hooks = [
      'onShow',
      'onHide',
      'onError',
      'onPageNotFound'];


    function parseBaseApp(vm, _ref3) {
      const { mocks } = _ref3;
      const { initRefs } = _ref3;
      _vue.default.prototype.mpHost = 'mp-weixin';

      _vue.default.mixin({
        beforeCreate: function beforeCreate() {
          if (!this.$options.mpType) {
            return;
          }

          this.mpType = this.$options.mpType;

          this.$mp = _defineProperty({ data: {} },
            this.mpType, this.$options.mpInstance);


          this.$scope = this.$options.mpInstance;

          delete this.$options.mpType;
          delete this.$options.mpInstance;

          if (this.mpType !== 'app') {
            initRefs(this);
            initMocks(this, mocks);
          }
        },
      });


      const appOptions = {
        onLaunch: function onLaunch(args) {
          {
            if (!wx.canIUse('nextTick')) { // 事实 上2.2.3 即可，简单使用 2.3.0 的 nextTick 判断
              console.error('当前微信基础库版本过低，请将 微信开发者工具-详情-项目设置-调试基础库版本 更换为`2.3.0`以上');
            }
          }

          this.$vm = vm;

          this.$vm.$mp = { app: this };


          this.$vm.$scope = this;

          this.$vm._isMounted = true;
          this.$vm.__call_hook('mounted', args);

          this.$vm.__call_hook('onLaunch', args);
        },
      };


      // 兼容旧版本 globalData
      appOptions.globalData = vm.$options.globalData || {};

      initHooks(appOptions, hooks);

      return appOptions;
    }

    const mocks = ['__route__', '__wxExparserNodeId__', '__wxWebviewId__'];

    function findVmByVueId(vm, vuePid) {
      const { $children } = vm;
      // 优先查找直属
      let parentVm = $children.find((childVm) => childVm.$scope._$vueId === vuePid);
      if (parentVm) {
        return parentVm;
      }
      // 反向递归查找
      for (let i = $children.length - 1; i >= 0; i--) {
        parentVm = findVmByVueId($children[i], vuePid);
        if (parentVm) {
          return parentVm;
        }
      }
    }

    function initBehavior(options) {
      return Behavior(options);
    }

    function isPage() {
      return !!this.route;
    }

    function initRelation(detail) {
      this.triggerEvent('__l', detail);
    }

    function initRefs(vm) {
      const mpInstance = vm.$scope;
      Object.defineProperty(vm, '$refs', {
        get: function get() {
          const $refs = {};
          const components = mpInstance.selectAllComponents('.vue-ref');
          components.forEach((component) => {
            const { ref } = component.dataset;
            $refs[ref] = component.$vm || component;
          });
          const forComponents = mpInstance.selectAllComponents('.vue-ref-in-for');
          forComponents.forEach((component) => {
            const { ref } = component.dataset;
            if (!$refs[ref]) {
              $refs[ref] = [];
            }
            $refs[ref].push(component.$vm || component);
          });
          return $refs;
        },
      });
    }

    function handleLink(event) {
      const _ref4 = event.detail || event.value; const { vuePid } = _ref4; const { vueOptions } = _ref4; // detail 是微信,value 是百度(dipatch)

      let parentVm;

      if (vuePid) {
        parentVm = findVmByVueId(this.$vm, vuePid);
      }

      if (!parentVm) {
        parentVm = this.$vm;
      }

      vueOptions.parent = parentVm;
    }

    function parseApp(vm) {
      return parseBaseApp(vm, {
        mocks,
        initRefs,
      });
    }

    function createApp(vm) {
      App(parseApp(vm));
      return vm;
    }

    function parseBaseComponent(vueComponentOptions) {
      const _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; const isPage$$1 = _ref5.isPage; const initRelation$$1 = _ref5.initRelation; const _initVueComponent = initVueComponent(_vue.default, vueComponentOptions); const _initVueComponent2 = _slicedToArray(_initVueComponent, 2); const VueComponent = _initVueComponent2[0]; const vueOptions = _initVueComponent2[1];

      const componentOptions = {
        options: {
          multipleSlots: true,
          addGlobalClass: true,
        },

        data: initData(vueOptions, _vue.default.prototype),
        behaviors: initBehaviors(vueOptions, initBehavior),
        properties: initProperties(vueOptions.props, false, vueOptions.__file),
        lifetimes: {
          attached: function attached() {
            const { properties } = this;

            const options = {
              mpType: isPage$$1.call(this) ? 'page' : 'component',
              mpInstance: this,
              propsData: properties,
            };


            initVueIds(properties.vueId, this);

            // 处理父子关系
            initRelation$$1.call(this, {
              vuePid: this._$vuePid,
              vueOptions: options,
            });


            // 初始化 vue 实例
            this.$vm = new VueComponent(options);

            // 处理$slots,$scopedSlots（暂不支持动态变化$slots）
            initSlots(this.$vm, properties.vueSlots);

            // 触发首次 setData
            this.$vm.$mount();
          },
          ready: function ready() {
            // 当组件 props 默认值为 true，初始化时传入 false 会导致 created,ready 触发, 但 attached 不触发
            // https://developers.weixin.qq.com/community/develop/doc/00066ae2844cc0f8eb883e2a557800
            if (this.$vm) {
              this.$vm._isMounted = true;
              this.$vm.__call_hook('mounted');
              this.$vm.__call_hook('onReady');
            }
          },
          detached: function detached() {
            this.$vm.$destroy();
          },
        },

        pageLifetimes: {
          show: function show(args) {
            this.$vm && this.$vm.__call_hook('onPageShow', args);
          },
          hide: function hide() {
            this.$vm && this.$vm.__call_hook('onPageHide');
          },
          resize: function resize(size) {
            this.$vm && this.$vm.__call_hook('onPageResize', size);
          },
        },

        methods: {
          __l: handleLink,
          __e: handleEvent,
        },
      };


      if (isPage$$1) {
        return componentOptions;
      }
      return [componentOptions, VueComponent];
    }

    function parseComponent(vueComponentOptions) {
      return parseBaseComponent(vueComponentOptions, {
        isPage,
        initRelation,
      });
    }

    const hooks$1 = [
      'onShow',
      'onHide',
      'onUnload'];


    hooks$1.push.apply(hooks$1, PAGE_EVENT_HOOKS);

    function parseBasePage(vuePageOptions, _ref6) {
      const { isPage } = _ref6;
      const { initRelation } = _ref6;
      const pageOptions = parseComponent(vuePageOptions, {
        isPage,
        initRelation,
      });


      initHooks(pageOptions.methods, hooks$1);

      pageOptions.methods.onLoad = function (args) {
        this.$vm.$mp.query = args; // 兼容 mpvue
        this.$vm.__call_hook('onLoad', args);
      };

      return pageOptions;
    }

    function parsePage(vuePageOptions) {
      return parseBasePage(vuePageOptions, {
        isPage,
        initRelation,
      });
    }

    function createPage(vuePageOptions) {
      {
        return Component(parsePage(vuePageOptions));
      }
    }

    function createComponent(vueOptions) {
      {
        return Component(parseComponent(vueOptions));
      }
    }

    todos.forEach((todoApi) => {
      protocols[todoApi] = false;
    });

    canIUses.forEach((canIUseApi) => {
      const apiName = protocols[canIUseApi] && protocols[canIUseApi].name ? protocols[canIUseApi].name
        : canIUseApi;
      if (!wx.canIUse(apiName)) {
        protocols[canIUseApi] = false;
      }
    });

    let uni = {};

    if (typeof Proxy !== 'undefined') {
      uni = new Proxy({}, {
        get: function get(target, name) {
          if (name === 'upx2px') {
            return upx2px;
          }
          if (api[name]) {
            return promisify(name, api[name]);
          }
          {
            if (extraApi[name]) {
              return promisify(name, extraApi[name]);
            }
            if (todoApis[name]) {
              return promisify(name, todoApis[name]);
            }
          }
          if (eventApi[name]) {
            return eventApi[name];
          }
          if (!hasOwn(wx, name) && !hasOwn(protocols, name)) {
            return;
          }
          return promisify(name, wrapper(name, wx[name]));
        },
      });
    } else {
      uni.upx2px = upx2px;

      {
        Object.keys(todoApis).forEach((name) => {
          uni[name] = promisify(name, todoApis[name]);
        });
        Object.keys(extraApi).forEach((name) => {
          uni[name] = promisify(name, todoApis[name]);
        });
      }

      Object.keys(eventApi).forEach((name) => {
        uni[name] = eventApi[name];
      });

      Object.keys(api).forEach((name) => {
        uni[name] = promisify(name, api[name]);
      });

      Object.keys(wx).forEach((name) => {
        if (hasOwn(wx, name) || hasOwn(protocols, name)) {
          uni[name] = promisify(name, wrapper(name, wx[name]));
        }
      });
    }

    wx.createApp = createApp;
    wx.createPage = createPage;
    wx.createComponent = createComponent;

    const uni$1 = uni; const _default = uni$1; exports.default = _default;
    /** */ }),

  /** */ './node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js':
  /*! ******************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js ***!
  \***************************************************************************************** */
  /*! exports provided: default */
  /** */ (function (module, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__);
    /* WEBPACK VAR INJECTION */(function (global) { /*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
      /*  */

      const emptyObject = Object.freeze({});

      // These helpers produce better VM code in JS engines due to their
      // explicitness and function inlining.
      function isUndef(v) {
        return v === undefined || v === null;
      }

      function isDef(v) {
        return v !== undefined && v !== null;
      }

      function isTrue(v) {
        return v === true;
      }

      function isFalse(v) {
        return v === false;
      }

      /**
 * Check if value is primitive.
 */
      function isPrimitive(value) {
        return (
          typeof value === 'string'
    || typeof value === 'number'
    // $flow-disable-line
    || typeof value === 'symbol'
    || typeof value === 'boolean'
        );
      }

      /**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
      function isObject(obj) {
        return obj !== null && typeof obj === 'object';
      }

      /**
 * Get the raw type string of a value, e.g., [object Object].
 */
      const _toString = Object.prototype.toString;

      function toRawType(value) {
        return _toString.call(value).slice(8, -1);
      }

      /**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
      function isPlainObject(obj) {
        return _toString.call(obj) === '[object Object]';
      }

      function isRegExp(v) {
        return _toString.call(v) === '[object RegExp]';
      }

      /**
 * Check if val is a valid array index.
 */
      function isValidArrayIndex(val) {
        const n = parseFloat(String(val));
        return n >= 0 && Math.floor(n) === n && isFinite(val);
      }

      function isPromise(val) {
        return (
          isDef(val)
    && typeof val.then === 'function'
    && typeof val.catch === 'function'
        );
      }

      /**
 * Convert a value to a string that is actually rendered.
 */
      function toString(val) {
        return val == null
          ? ''
          : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, null, 2)
            : String(val);
      }

      /**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
      function toNumber(val) {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      }

      /**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
      function makeMap(
        str,
        expectsLowerCase,
      ) {
        const map = Object.create(null);
        const list = str.split(',');
        for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
        }
        return expectsLowerCase
          ? function (val) { return map[val.toLowerCase()]; }
          : function (val) { return map[val]; };
      }

      /**
 * Check if a tag is a built-in tag.
 */
      const isBuiltInTag = makeMap('slot,component', true);

      /**
 * Check if an attribute is a reserved attribute.
 */
      const isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

      /**
 * Remove an item from an array.
 */
      function remove(arr, item) {
        if (arr.length) {
          const index = arr.indexOf(item);
          if (index > -1) {
            return arr.splice(index, 1);
          }
        }
      }

      /**
 * Check whether an object has the property.
 */
      const { hasOwnProperty } = Object.prototype;
      function hasOwn(obj, key) {
        return hasOwnProperty.call(obj, key);
      }

      /**
 * Create a cached version of a pure function.
 */
      function cached(fn) {
        const cache = Object.create(null);
        return (function cachedFn(str) {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        });
      }

      /**
 * Camelize a hyphen-delimited string.
 */
      const camelizeRE = /-(\w)/g;
      const camelize = cached((str) => str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : '')));

      /**
 * Capitalize a string.
 */
      const capitalize = cached((str) => str.charAt(0).toUpperCase() + str.slice(1));

      /**
 * Hyphenate a camelCase string.
 */
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cached((str) => str.replace(hyphenateRE, '-$1').toLowerCase());

      /**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

      /* istanbul ignore next */
      function polyfillBind(fn, ctx) {
        function boundFn(a) {
          const l = arguments.length;
          return l
            ? l > 1
              ? fn.apply(ctx, arguments)
              : fn.call(ctx, a)
            : fn.call(ctx);
        }

        boundFn._length = fn.length;
        return boundFn;
      }

      function nativeBind(fn, ctx) {
        return fn.bind(ctx);
      }

      const bind = Function.prototype.bind
        ? nativeBind
        : polyfillBind;

      /**
 * Convert an Array-like object to a real Array.
 */
      function toArray(list, start) {
        start = start || 0;
        let i = list.length - start;
        const ret = new Array(i);
        while (i--) {
          ret[i] = list[i + start];
        }
        return ret;
      }

      /**
 * Mix properties into target object.
 */
      function extend(to, _from) {
        for (const key in _from) {
          to[key] = _from[key];
        }
        return to;
      }

      /**
 * Merge an Array of Objects into a single Object.
 */
      function toObject(arr) {
        const res = {};
        for (let i = 0; i < arr.length; i++) {
          if (arr[i]) {
            extend(res, arr[i]);
          }
        }
        return res;
      }

      /* eslint-disable no-unused-vars */

      /**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
      function noop(a, b, c) {}

      /**
 * Always return false.
 */
      const no = function (a, b, c) { return false; };

      /* eslint-enable no-unused-vars */

      /**
 * Return the same value.
 */
      const identity = function (_) { return _; };

      /**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
      function looseEqual(a, b) {
        if (a === b) { return true; }
        const isObjectA = isObject(a);
        const isObjectB = isObject(b);
        if (isObjectA && isObjectB) {
          try {
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
              return a.length === b.length && a.every((e, i) => looseEqual(e, b[i]));
            } if (a instanceof Date && b instanceof Date) {
              return a.getTime() === b.getTime();
            } if (!isArrayA && !isArrayB) {
              const keysA = Object.keys(a);
              const keysB = Object.keys(b);
              return keysA.length === keysB.length && keysA.every((key) => looseEqual(a[key], b[key]));
            }
            /* istanbul ignore next */
            return false;
          } catch (e) {
            /* istanbul ignore next */
            return false;
          }
        } else if (!isObjectA && !isObjectB) {
          return String(a) === String(b);
        } else {
          return false;
        }
      }

      /**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
      function looseIndexOf(arr, val) {
        for (let i = 0; i < arr.length; i++) {
          if (looseEqual(arr[i], val)) { return i; }
        }
        return -1;
      }

      /**
 * Ensure a function is called only once.
 */
      function once(fn) {
        let called = false;
        return function () {
          if (!called) {
            called = true;
            fn.apply(this, arguments);
          }
        };
      }

      const ASSET_TYPES = [
        'component',
        'directive',
        'filter',
      ];

      const LIFECYCLE_HOOKS = [
        'beforeCreate',
        'created',
        'beforeMount',
        'mounted',
        'beforeUpdate',
        'updated',
        'beforeDestroy',
        'destroyed',
        'activated',
        'deactivated',
        'errorCaptured',
        'serverPrefetch',
      ];

      /*  */


      const config = ({
        /**
   * Option merge strategies (used in core/util/options)
   */
        // $flow-disable-line
        optionMergeStrategies: Object.create(null),

        /**
   * Whether to suppress warnings.
   */
        silent: false,

        /**
   * Show production mode tip message on boot?
   */
        productionTip: 'development' !== 'production',

        /**
   * Whether to enable devtools
   */
        devtools: 'development' !== 'production',

        /**
   * Whether to record perf
   */
        performance: false,

        /**
   * Error handler for watcher errors
   */
        errorHandler: null,

        /**
   * Warn handler for watcher warns
   */
        warnHandler: null,

        /**
   * Ignore certain custom elements
   */
        ignoredElements: [],

        /**
   * Custom user key aliases for v-on
   */
        // $flow-disable-line
        keyCodes: Object.create(null),

        /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
        isReservedTag: no,

        /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
        isReservedAttr: no,

        /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
        isUnknownElement: no,

        /**
   * Get the namespace of an element
   */
        getTagNamespace: noop,

        /**
   * Parse the real tag name for the specific platform.
   */
        parsePlatformTagName: identity,

        /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
        mustUseProp: no,

        /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
        async: true,

        /**
   * Exposed for legacy reasons
   */
        _lifecycleHooks: LIFECYCLE_HOOKS,
      });

      /*  */

      /**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
      const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

      /**
 * Check if a string starts with $ or _
 */
      function isReserved(str) {
        const c = (`${str}`).charCodeAt(0);
        return c === 0x24 || c === 0x5F;
      }

      /**
 * Define a property.
 */
      function def(obj, key, val, enumerable) {
        Object.defineProperty(obj, key, {
          value: val,
          enumerable: !!enumerable,
          writable: true,
          configurable: true,
        });
      }

      /**
 * Parse simple path.
 */
      const bailRE = new RegExp((`[^${unicodeRegExp.source}.$_\\d]`));
      function parsePath(path) {
        if (bailRE.test(path)) {
          return;
        }
        const segments = path.split('.');
        return function (obj) {
          for (let i = 0; i < segments.length; i++) {
            if (!obj) { return; }
            obj = obj[segments[i]];
          }
          return obj;
        };
      }

      /*  */

      // can we use __proto__?
      const hasProto = '__proto__' in {};

      // Browser environment sniffing
      const inBrowser = typeof window !== 'undefined';
      const inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
      const weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
      const UA = inBrowser && window.navigator.userAgent.toLowerCase();
      const isIE = UA && /msie|trident/.test(UA);
      const isIE9 = UA && UA.indexOf('msie 9.0') > 0;
      const isEdge = UA && UA.indexOf('edge/') > 0;
      const isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
      const isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
      const isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
      const isPhantomJS = UA && /phantomjs/.test(UA);
      const isFF = UA && UA.match(/firefox\/(\d+)/);

      // Firefox has a "watch" function on Object.prototype...
      const nativeWatch = ({}).watch;
      if (inBrowser) {
        try {
          const opts = {};
          Object.defineProperty(opts, 'passive', ({
            get: function get() {
            },
          })); // https://github.com/facebook/flow/issues/285
          window.addEventListener('test-passive', null, opts);
        } catch (e) {}
      }

      // this needs to be lazy-evaled because vue may be required before
      // vue-server-renderer can set VUE_ENV
      let _isServer;
      const isServerRendering = function () {
        if (_isServer === undefined) {
          /* istanbul ignore if */
          if (!inBrowser && !inWeex && typeof global !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer = global.process && global.process.env.VUE_ENV === 'server';
          } else {
            _isServer = false;
          }
        }
        return _isServer;
      };

      // detect devtools
      const devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

      /* istanbul ignore next */
      function isNative(Ctor) {
        return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
      }

      const hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol)
  && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

      let _Set;
      /* istanbul ignore if */ // $flow-disable-line
      if (typeof Set !== 'undefined' && isNative(Set)) {
        // use native Set when available.
        _Set = Set;
      } else {
        // a non-standard Set polyfill that only works with primitive keys.
        _Set = /* @__PURE__ */(function () {
          function Set() {
            this.set = Object.create(null);
          }
          Set.prototype.has = function has(key) {
            return this.set[key] === true;
          };
          Set.prototype.add = function add(key) {
            this.set[key] = true;
          };
          Set.prototype.clear = function clear() {
            this.set = Object.create(null);
          };

          return Set;
        }());
      }

      /*  */

      let warn = noop;
      let tip = noop;
      let generateComponentTrace = (noop); // work around flow check
      let formatComponentName = (noop);

      if (true) {
        const hasConsole = typeof console !== 'undefined';
        const classifyRE = /(?:^|[-_])(\w)/g;
        const classify = function (str) {
          return str
            .replace(classifyRE, (c) => c.toUpperCase())
            .replace(/[-_]/g, '');
        };

        warn = function (msg, vm) {
          const trace = vm ? generateComponentTrace(vm) : '';

          if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
          } else if (hasConsole && (!config.silent)) {
            console.error((`[Vue warn]: ${msg}${trace}`));
          }
        };

        tip = function (msg, vm) {
          if (hasConsole && (!config.silent)) {
            console.warn(`[Vue tip]: ${msg
            }${vm ? generateComponentTrace(vm) : ''}`);
          }
        };

        formatComponentName = function (vm, includeFile) {
          {
            if (vm.$scope && vm.$scope.is) {
              return vm.$scope.is;
            }
          }
          if (vm.$root === vm) {
            return '<Root>';
          }
          const options = typeof vm === 'function' && vm.cid != null
            ? vm.options
            : vm._isVue
              ? vm.$options || vm.constructor.options
              : vm;
          let name = options.name || options._componentTag;
          const file = options.__file;
          if (!name && file) {
            const match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
          }

          return (
            (name ? (`<${classify(name)}>`) : '<Anonymous>')
      + (file && includeFile !== false ? (` at ${file}`) : '')
          );
        };

        const repeat = function (str, n) {
          let res = '';
          while (n) {
            if (n % 2 === 1) { res += str; }
            if (n > 1) { str += str; }
            n >>= 1;
          }
          return res;
        };

        generateComponentTrace = function (vm) {
          if (vm._isVue && vm.$parent) {
            const tree = [];
            let currentRecursiveSequence = 0;
            while (vm) {
              if (tree.length > 0) {
                const last = tree[tree.length - 1];
                if (last.constructor === vm.constructor) {
                  currentRecursiveSequence++;
                  vm = vm.$parent;
                  continue;
                } else if (currentRecursiveSequence > 0) {
                  tree[tree.length - 1] = [last, currentRecursiveSequence];
                  currentRecursiveSequence = 0;
                }
              }
              tree.push(vm);
              vm = vm.$parent;
            }
            return `\n\nfound in\n\n${tree
              .map((vm, i) => (`${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${Array.isArray(vm)
                ? (`${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`)
                : formatComponentName(vm)}`))
              .join('\n')}`;
          }
          return (`\n\n(found in ${formatComponentName(vm)})`);
        };
      }

      /*  */

      let uid = 0;

      /**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
      const Dep = function Dep() {
        this.id = uid++;
        this.subs = [];
      };

      Dep.prototype.addSub = function addSub(sub) {
        this.subs.push(sub);
      };

      Dep.prototype.removeSub = function removeSub(sub) {
        remove(this.subs, sub);
      };

      Dep.prototype.depend = function depend() {
        if (Dep.target) {
          Dep.target.addDep(this);
        }
      };

      Dep.prototype.notify = function notify() {
        // stabilize the subscriber list first
        const subs = this.subs.slice();
        if (true && !config.async) {
          // subs aren't sorted in scheduler if not running async
          // we need to sort them now to make sure they fire in correct
          // order
          subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
          subs[i].update();
        }
      };

      // The current target watcher being evaluated.
      // This is globally unique because only one watcher
      // can be evaluated at a time.
      Dep.target = null;
      const targetStack = [];

      function pushTarget(target) {
        targetStack.push(target);
        Dep.target = target;
      }

      function popTarget() {
        targetStack.pop();
        Dep.target = targetStack[targetStack.length - 1];
      }

      /*  */

      const VNode = function VNode(
        tag,
        data,
        children,
        text,
        elm,
        context,
        componentOptions,
        asyncFactory,
      ) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
      };

      const prototypeAccessors = { child: { configurable: true } };

      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      prototypeAccessors.child.get = function () {
        return this.componentInstance;
      };

      Object.defineProperties(VNode.prototype, prototypeAccessors);

      const createEmptyVNode = function (text) {
        if (text === void 0) text = '';

        const node = new VNode();
        node.text = text;
        node.isComment = true;
        return node;
      };

      function createTextVNode(val) {
        return new VNode(undefined, undefined, undefined, String(val));
      }

      // optimized shallow clone
      // used for static nodes and slot nodes because they may be reused across
      // multiple renders, cloning them avoids errors when DOM manipulations rely
      // on their elm reference.
      function cloneVNode(vnode) {
        const cloned = new VNode(
          vnode.tag,
          vnode.data,
          // #7975
          // clone children array to avoid mutating original in case of cloning
          // a child.
          vnode.children && vnode.children.slice(),
          vnode.text,
          vnode.elm,
          vnode.context,
          vnode.componentOptions,
          vnode.asyncFactory,
        );
        cloned.ns = vnode.ns;
        cloned.isStatic = vnode.isStatic;
        cloned.key = vnode.key;
        cloned.isComment = vnode.isComment;
        cloned.fnContext = vnode.fnContext;
        cloned.fnOptions = vnode.fnOptions;
        cloned.fnScopeId = vnode.fnScopeId;
        cloned.asyncMeta = vnode.asyncMeta;
        cloned.isCloned = true;
        return cloned;
      }

      /*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

      const arrayProto = Array.prototype;
      const arrayMethods = Object.create(arrayProto);

      const methodsToPatch = [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse',
      ];

      /**
 * Intercept mutating methods and emit events
 */
      methodsToPatch.forEach((method) => {
        // cache original method
        const original = arrayProto[method];
        def(arrayMethods, method, function mutator() {
          const args = []; let
            len = arguments.length;
          while (len--) args[len] = arguments[len];

          const result = original.apply(this, args);
          const ob = this.__ob__;
          let inserted;
          switch (method) {
            case 'push':
            case 'unshift':
              inserted = args;
              break;
            case 'splice':
              inserted = args.slice(2);
              break;
          }
          if (inserted) { ob.observeArray(inserted); }
          // notify change
          ob.dep.notify();
          return result;
        });
      });

      /*  */

      const arrayKeys = Object.getOwnPropertyNames(arrayMethods);

      /**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
      let shouldObserve = true;

      function toggleObserving(value) {
        shouldObserve = value;
      }

      /**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
      const Observer = function Observer(value) {
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (Array.isArray(value)) {
          if (hasProto) {
            protoAugment(value, arrayMethods);
          } else {
            copyAugment(value, arrayMethods, arrayKeys);
          }
          this.observeArray(value);
        } else {
          this.walk(value);
        }
      };

      /**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
      Observer.prototype.walk = function walk(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
          defineReactive$$1(obj, keys[i]);
        }
      };

      /**
 * Observe a list of Array items.
 */
      Observer.prototype.observeArray = function observeArray(items) {
        for (let i = 0, l = items.length; i < l; i++) {
          observe(items[i]);
        }
      };

      // helpers

      /**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
      function protoAugment(target, src) {
        /* eslint-disable no-proto */
        target.__proto__ = src;
        /* eslint-enable no-proto */
      }

      /**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
      /* istanbul ignore next */
      function copyAugment(target, src, keys) {
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          def(target, key, src[key]);
        }
      }

      /**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
      function observe(value, asRootData) {
        if (!isObject(value) || value instanceof VNode) {
          return;
        }
        let ob;
        if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
          ob = value.__ob__;
        } else if (
          shouldObserve
    && !isServerRendering()
    && (Array.isArray(value) || isPlainObject(value))
    && Object.isExtensible(value)
    && !value._isVue
        ) {
          ob = new Observer(value);
        }
        if (asRootData && ob) {
          ob.vmCount++;
        }
        return ob;
      }

      /**
 * Define a reactive property on an Object.
 */
      function defineReactive$$1(
        obj,
        key,
        val,
        customSetter,
        shallow,
      ) {
        const dep = new Dep();

        const property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
          return;
        }

        // cater for pre-defined getter/setters
        const getter = property && property.get;
        const setter = property && property.set;
        if ((!getter || setter) && arguments.length === 2) {
          val = obj[key];
        }

        let childOb = !shallow && observe(val);
        Object.defineProperty(obj, key, {
          enumerable: true,
          configurable: true,
          get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val;
            if (Dep.target) {
              dep.depend();
              if (childOb) {
                childOb.dep.depend();
                if (Array.isArray(value)) {
                  dependArray(value);
                }
              }
            }
            return value;
          },
          set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            /* eslint-disable no-self-compare */
            if (newVal === value || (newVal !== newVal && value !== value)) {
              return;
            }
            /* eslint-enable no-self-compare */
            if (true && customSetter) {
              customSetter();
            }
            // #7981: for accessor properties without setter
            if (getter && !setter) { return; }
            if (setter) {
              setter.call(obj, newVal);
            } else {
              val = newVal;
            }
            childOb = !shallow && observe(newVal);
            dep.notify();
          },
        });
      }

      /**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
      function set(target, key, val) {
        if (true
    && (isUndef(target) || isPrimitive(target))
        ) {
          warn((`Cannot set reactive property on undefined, null, or primitive value: ${target}`));
        }
        if (Array.isArray(target) && isValidArrayIndex(key)) {
          target.length = Math.max(target.length, key);
          target.splice(key, 1, val);
          return val;
        }
        if (key in target && !(key in Object.prototype)) {
          target[key] = val;
          return val;
        }
        const ob = (target).__ob__;
        if (target._isVue || (ob && ob.vmCount)) {
          true && warn(
            'Avoid adding reactive properties to a Vue instance or its root $data '
      + 'at runtime - declare it upfront in the data option.',
          );
          return val;
        }
        if (!ob) {
          target[key] = val;
          return val;
        }
        defineReactive$$1(ob.value, key, val);
        ob.dep.notify();
        return val;
      }

      /**
 * Delete a property and trigger change if necessary.
 */
      function del(target, key) {
        if (true
    && (isUndef(target) || isPrimitive(target))
        ) {
          warn((`Cannot delete reactive property on undefined, null, or primitive value: ${target}`));
        }
        if (Array.isArray(target) && isValidArrayIndex(key)) {
          target.splice(key, 1);
          return;
        }
        const ob = (target).__ob__;
        if (target._isVue || (ob && ob.vmCount)) {
          true && warn(
            'Avoid deleting properties on a Vue instance or its root $data '
      + '- just set it to null.',
          );
          return;
        }
        if (!hasOwn(target, key)) {
          return;
        }
        delete target[key];
        if (!ob) {
          return;
        }
        ob.dep.notify();
      }

      /**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
      function dependArray(value) {
        for (let e = (void 0), i = 0, l = value.length; i < l; i++) {
          e = value[i];
          e && e.__ob__ && e.__ob__.dep.depend();
          if (Array.isArray(e)) {
            dependArray(e);
          }
        }
      }

      /*  */

      /**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
      const strats = config.optionMergeStrategies;

      /**
 * Options with restrictions
 */
      if (true) {
        strats.el = strats.propsData = function (parent, child, vm, key) {
          if (!vm) {
            warn(
              `option "${key}" can only be used during instance `
        + 'creation with the `new` keyword.',
            );
          }
          return defaultStrat(parent, child);
        };
      }

      /**
 * Helper that recursively merges two data objects together.
 */
      function mergeData(to, from) {
        if (!from) { return to; }
        let key; let toVal; let
          fromVal;

        const keys = hasSymbol
          ? Reflect.ownKeys(from)
          : Object.keys(from);

        for (let i = 0; i < keys.length; i++) {
          key = keys[i];
          // in case the object is already observed...
          if (key === '__ob__') { continue; }
          toVal = to[key];
          fromVal = from[key];
          if (!hasOwn(to, key)) {
            set(to, key, fromVal);
          } else if (
            toVal !== fromVal
      && isPlainObject(toVal)
      && isPlainObject(fromVal)
          ) {
            mergeData(toVal, fromVal);
          }
        }
        return to;
      }

      /**
 * Data
 */
      function mergeDataOrFn(
        parentVal,
        childVal,
        vm,
      ) {
        if (!vm) {
          // in a Vue.extend merge, both should be functions
          if (!childVal) {
            return parentVal;
          }
          if (!parentVal) {
            return childVal;
          }
          // when parentVal & childVal are both present,
          // we need to return a function that returns the
          // merged result of both functions... no need to
          // check if parentVal is a function here because
          // it has to be a function to pass previous merges.
          return function mergedDataFn() {
            return mergeData(
              typeof childVal === 'function' ? childVal.call(this, this) : childVal,
              typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal,
            );
          };
        }
        return function mergedInstanceDataFn() {
          // instance merge
          const instanceData = typeof childVal === 'function'
            ? childVal.call(vm, vm)
            : childVal;
          const defaultData = typeof parentVal === 'function'
            ? parentVal.call(vm, vm)
            : parentVal;
          if (instanceData) {
            return mergeData(instanceData, defaultData);
          }
          return defaultData;
        };
      }

      strats.data = function (
        parentVal,
        childVal,
        vm,
      ) {
        if (!vm) {
          if (childVal && typeof childVal !== 'function') {
            true && warn(
              'The "data" option should be a function '
        + 'that returns a per-instance value in component '
        + 'definitions.',
              vm,
            );

            return parentVal;
          }
          return mergeDataOrFn(parentVal, childVal);
        }

        return mergeDataOrFn(parentVal, childVal, vm);
      };

      /**
 * Hooks and props are merged as arrays.
 */
      function mergeHook(
        parentVal,
        childVal,
      ) {
        const res = childVal
          ? parentVal
            ? parentVal.concat(childVal)
            : Array.isArray(childVal)
              ? childVal
              : [childVal]
          : parentVal;
        return res
          ? dedupeHooks(res)
          : res;
      }

      function dedupeHooks(hooks) {
        const res = [];
        for (let i = 0; i < hooks.length; i++) {
          if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
          }
        }
        return res;
      }

      LIFECYCLE_HOOKS.forEach((hook) => {
        strats[hook] = mergeHook;
      });

      /**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
      function mergeAssets(
        parentVal,
        childVal,
        vm,
        key,
      ) {
        const res = Object.create(parentVal || null);
        if (childVal) {
          true && assertObjectType(key, childVal, vm);
          return extend(res, childVal);
        }
        return res;
      }

      ASSET_TYPES.forEach((type) => {
        strats[`${type}s`] = mergeAssets;
      });

      /**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
      strats.watch = function (
        parentVal,
        childVal,
        vm,
        key,
      ) {
        // work around Firefox's Object.prototype.watch...
        if (parentVal === nativeWatch) { parentVal = undefined; }
        if (childVal === nativeWatch) { childVal = undefined; }
        /* istanbul ignore if */
        if (!childVal) { return Object.create(parentVal || null); }
        if (true) {
          assertObjectType(key, childVal, vm);
        }
        if (!parentVal) { return childVal; }
        const ret = {};
        extend(ret, parentVal);
        for (const key$1 in childVal) {
          let parent = ret[key$1];
          const child = childVal[key$1];
          if (parent && !Array.isArray(parent)) {
            parent = [parent];
          }
          ret[key$1] = parent
            ? parent.concat(child)
            : Array.isArray(child) ? child : [child];
        }
        return ret;
      };

      /**
 * Other object hashes.
 */
      strats.props = strats.methods = strats.inject = strats.computed = function (
        parentVal,
        childVal,
        vm,
        key,
      ) {
        if (childVal && 'development' !== 'production') {
          assertObjectType(key, childVal, vm);
        }
        if (!parentVal) { return childVal; }
        const ret = Object.create(null);
        extend(ret, parentVal);
        if (childVal) { extend(ret, childVal); }
        return ret;
      };
      strats.provide = mergeDataOrFn;

      /**
 * Default strategy.
 */
      var defaultStrat = function (parentVal, childVal) {
        return childVal === undefined
          ? parentVal
          : childVal;
      };

      /**
 * Validate component names
 */
      function checkComponents(options) {
        for (const key in options.components) {
          validateComponentName(key);
        }
      }

      function validateComponentName(name) {
        if (!new RegExp((`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$`)).test(name)) {
          warn(
            `Invalid component name: "${name}". Component names `
      + 'should conform to valid custom element name in html5 specification.',
          );
        }
        if (isBuiltInTag(name) || config.isReservedTag(name)) {
          warn(
            `${'Do not use built-in or reserved HTML elements as component '
      + 'id: '}${name}`,
          );
        }
      }

      /**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
      function normalizeProps(options, vm) {
        const { props } = options;
        if (!props) { return; }
        const res = {};
        let i; let val; let
          name;
        if (Array.isArray(props)) {
          i = props.length;
          while (i--) {
            val = props[i];
            if (typeof val === 'string') {
              name = camelize(val);
              res[name] = { type: null };
            } else if (true) {
              warn('props must be strings when using array syntax.');
            }
          }
        } else if (isPlainObject(props)) {
          for (const key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val)
              ? val
              : { type: val };
          }
        } else if (true) {
          warn(
            `${'Invalid value for option "props": expected an Array or an Object, '
      + 'but got '}${toRawType(props)}.`,
            vm,
          );
        }
        options.props = res;
      }

      /**
 * Normalize all injections into Object-based format
 */
      function normalizeInject(options, vm) {
        const { inject } = options;
        if (!inject) { return; }
        const normalized = options.inject = {};
        if (Array.isArray(inject)) {
          for (let i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
          }
        } else if (isPlainObject(inject)) {
          for (const key in inject) {
            const val = inject[key];
            normalized[key] = isPlainObject(val)
              ? extend({ from: key }, val)
              : { from: val };
          }
        } else if (true) {
          warn(
            `${'Invalid value for option "inject": expected an Array or an Object, '
      + 'but got '}${toRawType(inject)}.`,
            vm,
          );
        }
      }

      /**
 * Normalize raw function directives into object format.
 */
      function normalizeDirectives(options) {
        const dirs = options.directives;
        if (dirs) {
          for (const key in dirs) {
            const def$$1 = dirs[key];
            if (typeof def$$1 === 'function') {
              dirs[key] = { bind: def$$1, update: def$$1 };
            }
          }
        }
      }

      function assertObjectType(name, value, vm) {
        if (!isPlainObject(value)) {
          warn(
            `Invalid value for option "${name}": expected an Object, `
      + `but got ${toRawType(value)}.`,
            vm,
          );
        }
      }

      /**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
      function mergeOptions(
        parent,
        child,
        vm,
      ) {
        if (true) {
          checkComponents(child);
        }

        if (typeof child === 'function') {
          child = child.options;
        }

        normalizeProps(child, vm);
        normalizeInject(child, vm);
        normalizeDirectives(child);

        // Apply extends and mixins on the child options,
        // but only if it is a raw options object that isn't
        // the result of another mergeOptions call.
        // Only merged options has the _base property.
        if (!child._base) {
          if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
          }
          if (child.mixins) {
            for (let i = 0, l = child.mixins.length; i < l; i++) {
              parent = mergeOptions(parent, child.mixins[i], vm);
            }
          }
        }

        const options = {};
        let key;
        for (key in parent) {
          mergeField(key);
        }
        for (key in child) {
          if (!hasOwn(parent, key)) {
            mergeField(key);
          }
        }
        function mergeField(key) {
          const strat = strats[key] || defaultStrat;
          options[key] = strat(parent[key], child[key], vm, key);
        }
        return options;
      }

      /**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
      function resolveAsset(
        options,
        type,
        id,
        warnMissing,
      ) {
        /* istanbul ignore if */
        if (typeof id !== 'string') {
          return;
        }
        const assets = options[type];
        // check local registration variations first
        if (hasOwn(assets, id)) { return assets[id]; }
        const camelizedId = camelize(id);
        if (hasOwn(assets, camelizedId)) { return assets[camelizedId]; }
        const PascalCaseId = capitalize(camelizedId);
        if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId]; }
        // fallback to prototype chain
        const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
        if (true && warnMissing && !res) {
          warn(
            `Failed to resolve ${type.slice(0, -1)}: ${id}`,
            options,
          );
        }
        return res;
      }

      /*  */


      function validateProp(
        key,
        propOptions,
        propsData,
        vm,
      ) {
        const prop = propOptions[key];
        const absent = !hasOwn(propsData, key);
        let value = propsData[key];
        // boolean casting
        const booleanIndex = getTypeIndex(Boolean, prop.type);
        if (booleanIndex > -1) {
          if (absent && !hasOwn(prop, 'default')) {
            value = false;
          } else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            const stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
              value = true;
            }
          }
        }
        // check default value
        if (value === undefined) {
          value = getPropDefaultValue(vm, prop, key);
          // since the default value is a fresh copy,
          // make sure to observe it.
          const prevShouldObserve = shouldObserve;
          toggleObserving(true);
          observe(value);
          toggleObserving(prevShouldObserve);
        }
        if (
          true
        ) {
          assertProp(prop, key, value, vm, absent);
        }
        return value;
      }

      /**
 * Get the default value of a prop.
 */
      function getPropDefaultValue(vm, prop, key) {
        // no default, return undefined
        if (!hasOwn(prop, 'default')) {
          return undefined;
        }
        const def = prop.default;
        // warn against non-factory defaults for Object & Array
        if (true && isObject(def)) {
          warn(
            `Invalid default value for prop "${key}": `
      + 'Props with type Object/Array must use a factory function '
      + 'to return the default value.',
            vm,
          );
        }
        // the raw prop value was also undefined from previous render,
        // return previous default value to avoid unnecessary watcher trigger
        if (vm && vm.$options.propsData
    && vm.$options.propsData[key] === undefined
    && vm._props[key] !== undefined
        ) {
          return vm._props[key];
        }
        // call factory function for non-Function types
        // a value is Function if its prototype is function even across different execution context
        return typeof def === 'function' && getType(prop.type) !== 'Function'
          ? def.call(vm)
          : def;
      }

      /**
 * Assert whether a prop is valid.
 */
      function assertProp(
        prop,
        name,
        value,
        vm,
        absent,
      ) {
        if (prop.required && absent) {
          warn(
            `Missing required prop: "${name}"`,
            vm,
          );
          return;
        }
        if (value == null && !prop.required) {
          return;
        }
        let { type } = prop;
        let valid = !type || type === true;
        const expectedTypes = [];
        if (type) {
          if (!Array.isArray(type)) {
            type = [type];
          }
          for (let i = 0; i < type.length && !valid; i++) {
            const assertedType = assertType(value, type[i]);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
          }
        }

        if (!valid) {
          warn(
            getInvalidTypeMessage(name, value, expectedTypes),
            vm,
          );
          return;
        }
        const { validator } = prop;
        if (validator) {
          if (!validator(value)) {
            warn(
              `Invalid prop: custom validator check failed for prop "${name}".`,
              vm,
            );
          }
        }
      }

      const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

      function assertType(value, type) {
        let valid;
        const expectedType = getType(type);
        if (simpleCheckRE.test(expectedType)) {
          const t = typeof value;
          valid = t === expectedType.toLowerCase();
          // for primitive wrapper objects
          if (!valid && t === 'object') {
            valid = value instanceof type;
          }
        } else if (expectedType === 'Object') {
          valid = isPlainObject(value);
        } else if (expectedType === 'Array') {
          valid = Array.isArray(value);
        } else {
          valid = value instanceof type;
        }
        return {
          valid,
          expectedType,
        };
      }

      /**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
      function getType(fn) {
        const match = fn && fn.toString().match(/^\s*function (\w+)/);
        return match ? match[1] : '';
      }

      function isSameType(a, b) {
        return getType(a) === getType(b);
      }

      function getTypeIndex(type, expectedTypes) {
        if (!Array.isArray(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
        }
        for (let i = 0, len = expectedTypes.length; i < len; i++) {
          if (isSameType(expectedTypes[i], type)) {
            return i;
          }
        }
        return -1;
      }

      function getInvalidTypeMessage(name, value, expectedTypes) {
        let message = `Invalid prop: type check failed for prop "${name}".`
    + ` Expected ${expectedTypes.map(capitalize).join(', ')}`;
        const expectedType = expectedTypes[0];
        const receivedType = toRawType(value);
        const expectedValue = styleValue(value, expectedType);
        const receivedValue = styleValue(value, receivedType);
        // check if we need to specify expected value
        if (expectedTypes.length === 1
      && isExplicable(expectedType)
      && !isBoolean(expectedType, receivedType)) {
          message += ` with value ${expectedValue}`;
        }
        message += `, got ${receivedType} `;
        // check if we need to specify received value
        if (isExplicable(receivedType)) {
          message += `with value ${receivedValue}.`;
        }
        return message;
      }

      function styleValue(value, type) {
        if (type === 'String') {
          return (`"${value}"`);
        } if (type === 'Number') {
          return (`${Number(value)}`);
        }
        return (`${value}`);
      }

      function isExplicable(value) {
        const explicitTypes = ['string', 'number', 'boolean'];
        return explicitTypes.some((elem) => value.toLowerCase() === elem);
      }

      function isBoolean() {
        const args = []; let
          len = arguments.length;
        while (len--) args[len] = arguments[len];

        return args.some((elem) => elem.toLowerCase() === 'boolean');
      }

      /*  */

      function handleError(err, vm, info) {
        // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
        // See: https://github.com/vuejs/vuex/issues/1505
        pushTarget();
        try {
          if (vm) {
            let cur = vm;
            while ((cur = cur.$parent)) {
              const hooks = cur.$options.errorCaptured;
              if (hooks) {
                for (let i = 0; i < hooks.length; i++) {
                  try {
                    const capture = hooks[i].call(cur, err, vm, info) === false;
                    if (capture) { return; }
                  } catch (e) {
                    globalHandleError(e, cur, 'errorCaptured hook');
                  }
                }
              }
            }
          }
          globalHandleError(err, vm, info);
        } finally {
          popTarget();
        }
      }

      function invokeWithErrorHandling(
        handler,
        context,
        args,
        vm,
        info,
      ) {
        let res;
        try {
          res = args ? handler.apply(context, args) : handler.call(context);
          if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch((e) => handleError(e, vm, `${info} (Promise/async)`));
            // issue #9511
            // avoid catch triggering multiple times when nested calls
            res._handled = true;
          }
        } catch (e) {
          handleError(e, vm, info);
        }
        return res;
      }

      function globalHandleError(err, vm, info) {
        if (config.errorHandler) {
          try {
            return config.errorHandler.call(null, err, vm, info);
          } catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
              logError(e, null, 'config.errorHandler');
            }
          }
        }
        logError(err, vm, info);
      }

      function logError(err, vm, info) {
        if (true) {
          warn((`Error in ${info}: "${err.toString()}"`), vm);
        }
        /* istanbul ignore else */
        if ((inBrowser || inWeex) && typeof console !== 'undefined') {
          console.error(err);
        } else {
          throw err;
        }
      }

      /*  */

      const callbacks = [];
      let pending = false;

      function flushCallbacks() {
        pending = false;
        const copies = callbacks.slice(0);
        callbacks.length = 0;
        for (let i = 0; i < copies.length; i++) {
          copies[i]();
        }
      }

      // Here we have async deferring wrappers using microtasks.
      // In 2.5 we used (macro) tasks (in combination with microtasks).
      // However, it has subtle problems when state is changed right before repaint
      // (e.g. #6813, out-in transitions).
      // Also, using (macro) tasks in event handler would cause some weird behaviors
      // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
      // So we now use microtasks everywhere, again.
      // A major drawback of this tradeoff is that there are some scenarios
      // where microtasks have too high a priority and fire in between supposedly
      // sequential events (e.g. #4521, #6690, which have workarounds)
      // or even between bubbling of the same event (#6566).
      let timerFunc;

      // The nextTick behavior leverages the microtask queue, which can be accessed
      // via either native Promise.then or MutationObserver.
      // MutationObserver has wider support, however it is seriously bugged in
      // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
      // completely stops working after triggering a few times... so, if native
      // Promise is available, we will use it:
      /* istanbul ignore next, $flow-disable-line */
      if (typeof Promise !== 'undefined' && isNative(Promise)) {
        const p = Promise.resolve();
        timerFunc = function () {
          p.then(flushCallbacks);
          // In problematic UIWebViews, Promise.then doesn't completely break, but
          // it can get stuck in a weird state where callbacks are pushed into the
          // microtask queue but the queue isn't being flushed, until the browser
          // needs to do some other work, e.g. handle a timer. Therefore we can
          // "force" the microtask queue to be flushed by adding an empty timer.
          if (isIOS) { setTimeout(noop); }
        };
      } else if (!isIE && typeof MutationObserver !== 'undefined' && (
        isNative(MutationObserver)
  // PhantomJS and iOS 7.x
  || MutationObserver.toString() === '[object MutationObserverConstructor]'
      )) {
        // Use MutationObserver where native Promise is not available,
        // e.g. PhantomJS, iOS7, Android 4.4
        // (#6466 MutationObserver is unreliable in IE11)
        let counter = 1;
        const observer = new MutationObserver(flushCallbacks);
        const textNode = document.createTextNode(String(counter));
        observer.observe(textNode, {
          characterData: true,
        });
        timerFunc = function () {
          counter = (counter + 1) % 2;
          textNode.data = String(counter);
        };
      } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
        // Fallback to setImmediate.
        // Techinically it leverages the (macro) task queue,
        // but it is still a better choice than setTimeout.
        timerFunc = function () {
          setImmediate(flushCallbacks);
        };
      } else {
        // Fallback to setTimeout.
        timerFunc = function () {
          setTimeout(flushCallbacks, 0);
        };
      }

      function nextTick(cb, ctx) {
        let _resolve;
        callbacks.push(() => {
          if (cb) {
            try {
              cb.call(ctx);
            } catch (e) {
              handleError(e, ctx, 'nextTick');
            }
          } else if (_resolve) {
            _resolve(ctx);
          }
        });
        if (!pending) {
          pending = true;
          timerFunc();
        }
        // $flow-disable-line
        if (!cb && typeof Promise !== 'undefined') {
          return new Promise(((resolve) => {
            _resolve = resolve;
          }));
        }
      }

      /*  */

      /* not type checking this file because flow doesn't play well with Proxy */

      let initProxy;

      if (true) {
        const allowedGlobals = makeMap(
          'Infinity,undefined,NaN,isFinite,isNaN,'
    + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'
    + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'
    + 'require', // for Webpack/Browserify
        );

        const warnNonPresent = function (target, key) {
          warn(
            `Property or method "${key}" is not defined on the instance but `
      + 'referenced during render. Make sure that this property is reactive, '
      + 'either in the data option, or for class-based components, by '
      + 'initializing the property. '
      + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
            target,
          );
        };

        const warnReservedPrefix = function (target, key) {
          warn(
            `Property "${key}" must be accessed with "$data.${key}" because `
      + 'properties starting with "$" or "_" are not proxied in the Vue instance to '
      + 'prevent conflicts with Vue internals'
      + 'See: https://vuejs.org/v2/api/#data',
            target,
          );
        };

        const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

        if (hasProxy) {
          const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
          config.keyCodes = new Proxy(config.keyCodes, {
            set: function set(target, key, value) {
              if (isBuiltInModifier(key)) {
                warn((`Avoid overwriting built-in modifier in config.keyCodes: .${key}`));
                return false;
              }
              target[key] = value;
              return true;
            },
          });
        }

        const hasHandler = {
          has: function has(target, key) {
            const has = key in target;
            const isAllowed = allowedGlobals(key)
        || (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
            if (!has && !isAllowed) {
              if (key in target.$data) { warnReservedPrefix(target, key); } else { warnNonPresent(target, key); }
            }
            return has || !isAllowed;
          },
        };

        const getHandler = {
          get: function get(target, key) {
            if (typeof key === 'string' && !(key in target)) {
              if (key in target.$data) { warnReservedPrefix(target, key); } else { warnNonPresent(target, key); }
            }
            return target[key];
          },
        };

        initProxy = function initProxy(vm) {
          if (hasProxy) {
            // determine which proxy handler to use
            const options = vm.$options;
            const handlers = options.render && options.render._withStripped
              ? getHandler
              : hasHandler;
            vm._renderProxy = new Proxy(vm, handlers);
          } else {
            vm._renderProxy = vm;
          }
        };
      }

      /*  */

      const seenObjects = new _Set();

      /**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
      function traverse(val) {
        _traverse(val, seenObjects);
        seenObjects.clear();
      }

      function _traverse(val, seen) {
        let i; let
          keys;
        const isA = Array.isArray(val);
        if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
          return;
        }
        if (val.__ob__) {
          const depId = val.__ob__.dep.id;
          if (seen.has(depId)) {
            return;
          }
          seen.add(depId);
        }
        if (isA) {
          i = val.length;
          while (i--) { _traverse(val[i], seen); }
        } else {
          keys = Object.keys(val);
          i = keys.length;
          while (i--) { _traverse(val[keys[i]], seen); }
        }
      }

      let mark;
      let measure;

      if (true) {
        const perf = inBrowser && window.performance;
        /* istanbul ignore if */
        if (
          perf
    && perf.mark
    && perf.measure
    && perf.clearMarks
    && perf.clearMeasures
        ) {
          mark = function (tag) { return perf.mark(tag); };
          measure = function (name, startTag, endTag) {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
            // perf.clearMeasures(name)
          };
        }
      }

      /*  */

      const normalizeEvent = cached((name) => {
        const passive = name.charAt(0) === '&';
        name = passive ? name.slice(1) : name;
        const once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
        name = once$$1 ? name.slice(1) : name;
        const capture = name.charAt(0) === '!';
        name = capture ? name.slice(1) : name;
        return {
          name,
          once: once$$1,
          capture,
          passive,
        };
      });

      function createFnInvoker(fns, vm) {
        function invoker() {
          const arguments$1 = arguments;

          const { fns } = invoker;
          if (Array.isArray(fns)) {
            const cloned = fns.slice();
            for (let i = 0; i < cloned.length; i++) {
              invokeWithErrorHandling(cloned[i], null, arguments$1, vm, 'v-on handler');
            }
          } else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, 'v-on handler');
          }
        }
        invoker.fns = fns;
        return invoker;
      }

      function updateListeners(
        on,
        oldOn,
        add,
        remove$$1,
        createOnceHandler,
        vm,
      ) {
        let name; let def$$1; let cur; let old; let
          event;
        for (name in on) {
          def$$1 = cur = on[name];
          old = oldOn[name];
          event = normalizeEvent(name);
          if (isUndef(cur)) {
            true && warn(
              `Invalid handler for event "${event.name}": got ${String(cur)}`,
              vm,
            );
          } else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
              cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
              cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
          } else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
          }
        }
        for (name in oldOn) {
          if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove$$1(event.name, oldOn[name], event.capture);
          }
        }
      }

      /*  */

      /*  */

      function extractPropsFromVNodeData(
        data,
        Ctor,
        tag,
      ) {
        // we are only extracting raw values here.
        // validation and default values are handled in the child
        // component itself.
        const propOptions = Ctor.options.props;
        if (isUndef(propOptions)) {
          return;
        }
        const res = {};
        const { attrs } = data;
        const { props } = data;
        if (isDef(attrs) || isDef(props)) {
          for (const key in propOptions) {
            const altKey = hyphenate(key);
            if (true) {
              const keyInLowerCase = key.toLowerCase();
              if (
                key !== keyInLowerCase
          && attrs && hasOwn(attrs, keyInLowerCase)
              ) {
                tip(
                  `Prop "${keyInLowerCase}" is passed to component ${
                    formatComponentName(tag || Ctor)}, but the declared prop name is`
            + ` "${key}". `
            + 'Note that HTML attributes are case-insensitive and camelCased '
            + 'props need to use their kebab-case equivalents when using in-DOM '
            + `templates. You should probably use "${altKey}" instead of "${key}".`,
                );
              }
            }
            checkProp(res, props, key, altKey, true)
      || checkProp(res, attrs, key, altKey, false);
          }
        }
        return res;
      }

      function checkProp(
        res,
        hash,
        key,
        altKey,
        preserve,
      ) {
        if (isDef(hash)) {
          if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
              delete hash[key];
            }
            return true;
          } if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
              delete hash[altKey];
            }
            return true;
          }
        }
        return false;
      }

      /*  */

      // The template compiler attempts to minimize the need for normalization by
      // statically analyzing the template at compile time.
      //
      // For plain HTML markup, normalization can be completely skipped because the
      // generated render function is guaranteed to return Array<VNode>. There are
      // two cases where extra normalization is needed:

      // 1. When the children contains components - because a functional component
      // may return an Array instead of a single root. In this case, just a simple
      // normalization is needed - if any child is an Array, we flatten the whole
      // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
      // because functional components already normalize their own children.
      function simpleNormalizeChildren(children) {
        for (let i = 0; i < children.length; i++) {
          if (Array.isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
          }
        }
        return children;
      }

      // 2. When the children contains constructs that always generated nested Arrays,
      // e.g. <template>, <slot>, v-for, or when the children is provided by user
      // with hand-written render functions / JSX. In such cases a full normalization
      // is needed to cater to all possible types of children values.
      function normalizeChildren(children) {
        return isPrimitive(children)
          ? [createTextVNode(children)]
          : Array.isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
      }

      function isTextNode(node) {
        return isDef(node) && isDef(node.text) && isFalse(node.isComment);
      }

      function normalizeArrayChildren(children, nestedIndex) {
        const res = [];
        let i; let c; let lastIndex; let
          last;
        for (i = 0; i < children.length; i++) {
          c = children[i];
          if (isUndef(c) || typeof c === 'boolean') { continue; }
          lastIndex = res.length - 1;
          last = res[lastIndex];
          //  nested
          if (Array.isArray(c)) {
            if (c.length > 0) {
              c = normalizeArrayChildren(c, (`${nestedIndex || ''}_${i}`));
              // merge adjacent text nodes
              if (isTextNode(c[0]) && isTextNode(last)) {
                res[lastIndex] = createTextVNode(last.text + (c[0]).text);
                c.shift();
              }
              res.push.apply(res, c);
            }
          } else if (isPrimitive(c)) {
            if (isTextNode(last)) {
              // merge adjacent text nodes
              // this is necessary for SSR hydration because text nodes are
              // essentially merged when rendered to HTML strings
              res[lastIndex] = createTextVNode(last.text + c);
            } else if (c !== '') {
              // convert primitive to vnode
              res.push(createTextVNode(c));
            }
          } else if (isTextNode(c) && isTextNode(last)) {
            // merge adjacent text nodes
            res[lastIndex] = createTextVNode(last.text + c.text);
          } else {
            // default key for nested array children (likely generated by v-for)
            if (isTrue(children._isVList)
          && isDef(c.tag)
          && isUndef(c.key)
          && isDef(nestedIndex)) {
              c.key = `__vlist${nestedIndex}_${i}__`;
            }
            res.push(c);
          }
        }
        return res;
      }

      /*  */

      function initProvide(vm) {
        const { provide } = vm.$options;
        if (provide) {
          vm._provided = typeof provide === 'function'
            ? provide.call(vm)
            : provide;
        }
      }

      function initInjections(vm) {
        const result = resolveInject(vm.$options.inject, vm);
        if (result) {
          toggleObserving(false);
          Object.keys(result).forEach((key) => {
            /* istanbul ignore else */
            if (true) {
              defineReactive$$1(vm, key, result[key], () => {
                warn(
                  `${'Avoid mutating an injected value directly since the changes will be '
            + 'overwritten whenever the provided component re-renders. '
            + 'injection being mutated: "'}${key}"`,
                  vm,
                );
              });
            } else {}
          });
          toggleObserving(true);
        }
      }

      function resolveInject(inject, vm) {
        if (inject) {
          // inject is :any because flow is not smart enough to figure out cached
          const result = Object.create(null);
          const keys = hasSymbol
            ? Reflect.ownKeys(inject)
            : Object.keys(inject);

          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__') { continue; }
            const provideKey = inject[key].from;
            let source = vm;
            while (source) {
              if (source._provided && hasOwn(source._provided, provideKey)) {
                result[key] = source._provided[provideKey];
                break;
              }
              source = source.$parent;
            }
            if (!source) {
              if ('default' in inject[key]) {
                const provideDefault = inject[key].default;
                result[key] = typeof provideDefault === 'function'
                  ? provideDefault.call(vm)
                  : provideDefault;
              } else if (true) {
                warn((`Injection "${key}" not found`), vm);
              }
            }
          }
          return result;
        }
      }

      /*  */


      /**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
      function resolveSlots(
        children,
        context,
      ) {
        if (!children || !children.length) {
          return {};
        }
        const slots = {};
        for (let i = 0, l = children.length; i < l; i++) {
          const child = children[i];
          const { data } = child;
          // remove slot attribute if the node is resolved as a Vue slot node
          if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
          }
          // named slots should only be respected if the vnode was rendered in the
          // same context.
          if ((child.context === context || child.fnContext === context)
      && data && data.slot != null
          ) {
            const name = data.slot;
            const slot = (slots[name] || (slots[name] = []));
            if (child.tag === 'template') {
              slot.push.apply(slot, child.children || []);
            } else {
              slot.push(child);
            }
          } else {
            (slots.default || (slots.default = [])).push(child);
          }
        }
        // ignore slots that contains only whitespace
        for (const name$1 in slots) {
          if (slots[name$1].every(isWhitespace)) {
            delete slots[name$1];
          }
        }
        return slots;
      }

      function isWhitespace(node) {
        return (node.isComment && !node.asyncFactory) || node.text === ' ';
      }

      /*  */

      function normalizeScopedSlots(
        slots,
        normalSlots,
        prevSlots,
      ) {
        let res;
        const hasNormalSlots = Object.keys(normalSlots).length > 0;
        const isStable = slots ? !!slots.$stable : !hasNormalSlots;
        const key = slots && slots.$key;
        if (!slots) {
          res = {};
        } else if (slots._normalized) {
          // fast path 1: child component re-render only, parent did not change
          return slots._normalized;
        } else if (
          isStable
    && prevSlots
    && prevSlots !== emptyObject
    && key === prevSlots.$key
    && !hasNormalSlots
    && !prevSlots.$hasNormal
        ) {
          // fast path 2: stable scoped slots w/ no normal slots to proxy,
          // only need to normalize once
          return prevSlots;
        } else {
          res = {};
          for (const key$1 in slots) {
            if (slots[key$1] && key$1[0] !== '$') {
              res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
            }
          }
        }
        // expose normal slots on scopedSlots
        for (const key$2 in normalSlots) {
          if (!(key$2 in res)) {
            res[key$2] = proxyNormalSlot(normalSlots, key$2);
          }
        }
        // avoriaz seems to mock a non-extensible $scopedSlots object
        // and when that is passed down this would cause an error
        if (slots && Object.isExtensible(slots)) {
          (slots)._normalized = res;
        }
        def(res, '$stable', isStable);
        def(res, '$key', key);
        def(res, '$hasNormal', hasNormalSlots);
        return res;
      }

      function normalizeScopedSlot(normalSlots, key, fn) {
        const normalized = function () {
          let res = arguments.length ? fn.apply(null, arguments) : fn({});
          res = res && typeof res === 'object' && !Array.isArray(res)
            ? [res] // single vnode
            : normalizeChildren(res);
          return res && (
            res.length === 0
      || (res.length === 1 && res[0].isComment) // #9658
          ) ? undefined
            : res;
        };
        // this is a slot using the new v-slot syntax without scope. although it is
        // compiled as a scoped slot, render fn users would expect it to be present
        // on this.$slots because the usage is semantically a normal slot.
        if (fn.proxy) {
          Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true,
          });
        }
        return normalized;
      }

      function proxyNormalSlot(slots, key) {
        return function () { return slots[key]; };
      }

      /*  */

      /**
 * Runtime helper for rendering v-for lists.
 */
      function renderList(
        val,
        render,
      ) {
        let ret; let i; let l; let keys; let
          key;
        if (Array.isArray(val) || typeof val === 'string') {
          ret = new Array(val.length);
          for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
          }
        } else if (typeof val === 'number') {
          ret = new Array(val);
          for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
          }
        } else if (isObject(val)) {
          if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            const iterator = val[Symbol.iterator]();
            let result = iterator.next();
            while (!result.done) {
              ret.push(render(result.value, ret.length));
              result = iterator.next();
            }
          } else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              ret[i] = render(val[key], key, i);
            }
          }
        }
        if (!isDef(ret)) {
          ret = [];
        }
        (ret)._isVList = true;
        return ret;
      }

      /*  */

      /**
 * Runtime helper for rendering <slot>
 */
      function renderSlot(
        name,
        fallback,
        props,
        bindObject,
      ) {
        const scopedSlotFn = this.$scopedSlots[name];
        let nodes;
        if (scopedSlotFn) { // scoped slot
          props = props || {};
          if (bindObject) {
            if (true && !isObject(bindObject)) {
              warn(
                'slot v-bind without argument expects an Object',
                this,
              );
            }
            props = extend(extend({}, bindObject), props);
          }
          nodes = scopedSlotFn(props) || fallback;
        } else {
          nodes = this.$slots[name] || fallback;
        }

        const target = props && props.slot;
        if (target) {
          return this.$createElement('template', { slot: target }, nodes);
        }
        return nodes;
      }

      /*  */

      /**
 * Runtime helper for resolving filters
 */
      function resolveFilter(id) {
        return resolveAsset(this.$options, 'filters', id, true) || identity;
      }

      /*  */

      function isKeyNotMatch(expect, actual) {
        if (Array.isArray(expect)) {
          return expect.indexOf(actual) === -1;
        }
        return expect !== actual;
      }

      /**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
      function checkKeyCodes(
        eventKeyCode,
        key,
        builtInKeyCode,
        eventKeyName,
        builtInKeyName,
      ) {
        const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
        if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
          return isKeyNotMatch(builtInKeyName, eventKeyName);
        } if (mappedKeyCode) {
          return isKeyNotMatch(mappedKeyCode, eventKeyCode);
        } if (eventKeyName) {
          return hyphenate(eventKeyName) !== key;
        }
      }

      /*  */

      /**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
      function bindObjectProps(
        data,
        tag,
        value,
        asProp,
        isSync,
      ) {
        if (value) {
          if (!isObject(value)) {
            true && warn(
              'v-bind without argument expects an Object or Array value',
              this,
            );
          } else {
            if (Array.isArray(value)) {
              value = toObject(value);
            }
            let hash;
            const loop = function (key) {
              if (
                key === 'class'
          || key === 'style'
          || isReservedAttribute(key)
              ) {
                hash = data;
              } else {
                const type = data.attrs && data.attrs.type;
                hash = asProp || config.mustUseProp(tag, type, key)
                  ? data.domProps || (data.domProps = {})
                  : data.attrs || (data.attrs = {});
              }
              const camelizedKey = camelize(key);
              const hyphenatedKey = hyphenate(key);
              if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                hash[key] = value[key];

                if (isSync) {
                  const on = data.on || (data.on = {});
                  on[(`update:${key}`)] = function ($event) {
                    value[key] = $event;
                  };
                }
              }
            };

            for (const key in value) loop(key);
          }
        }
        return data;
      }

      /*  */

      /**
 * Runtime helper for rendering static trees.
 */
      function renderStatic(
        index,
        isInFor,
      ) {
        const cached = this._staticTrees || (this._staticTrees = []);
        let tree = cached[index];
        // if has already-rendered static tree and not inside v-for,
        // we can reuse the same tree.
        if (tree && !isInFor) {
          return tree;
        }
        // otherwise, render a fresh tree.
        tree = cached[index] = this.$options.staticRenderFns[index].call(
          this._renderProxy,
          null,
          this, // for render fns generated for functional component templates
        );
        markStatic(tree, (`__static__${index}`), false);
        return tree;
      }

      /**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
      function markOnce(
        tree,
        index,
        key,
      ) {
        markStatic(tree, (`__once__${index}${key ? (`_${key}`) : ''}`), true);
        return tree;
      }

      function markStatic(
        tree,
        key,
        isOnce,
      ) {
        if (Array.isArray(tree)) {
          for (let i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
              markStaticNode(tree[i], (`${key}_${i}`), isOnce);
            }
          }
        } else {
          markStaticNode(tree, key, isOnce);
        }
      }

      function markStaticNode(node, key, isOnce) {
        node.isStatic = true;
        node.key = key;
        node.isOnce = isOnce;
      }

      /*  */

      function bindObjectListeners(data, value) {
        if (value) {
          if (!isPlainObject(value)) {
            true && warn(
              'v-on without argument expects an Object value',
              this,
            );
          } else {
            const on = data.on = data.on ? extend({}, data.on) : {};
            for (const key in value) {
              const existing = on[key];
              const ours = value[key];
              on[key] = existing ? [].concat(existing, ours) : ours;
            }
          }
        }
        return data;
      }

      /*  */

      function resolveScopedSlots(
        fns, // see flow/vnode
        res,
        // the following are added in 2.6
        hasDynamicKeys,
        contentHashKey,
      ) {
        res = res || { $stable: !hasDynamicKeys };
        for (let i = 0; i < fns.length; i++) {
          const slot = fns[i];
          if (Array.isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
          } else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            if (slot.proxy) {
              slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
          }
        }
        if (contentHashKey) {
          (res).$key = contentHashKey;
        }
        return res;
      }

      /*  */

      function bindDynamicKeys(baseObj, values) {
        for (let i = 0; i < values.length; i += 2) {
          const key = values[i];
          if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
          } else if (true && key !== '' && key !== null) {
            // null is a speical value for explicitly removing a binding
            warn(
              (`Invalid value for dynamic directive argument (expected string or null): ${key}`),
              this,
            );
          }
        }
        return baseObj;
      }

      // helper to dynamically append modifier runtime markers to event names.
      // ensure only append when value is already string, otherwise it will be cast
      // to string and cause the type check to miss.
      function prependModifier(value, symbol) {
        return typeof value === 'string' ? symbol + value : value;
      }

      /*  */

      function installRenderHelpers(target) {
        target._o = markOnce;
        target._n = toNumber;
        target._s = toString;
        target._l = renderList;
        target._t = renderSlot;
        target._q = looseEqual;
        target._i = looseIndexOf;
        target._m = renderStatic;
        target._f = resolveFilter;
        target._k = checkKeyCodes;
        target._b = bindObjectProps;
        target._v = createTextVNode;
        target._e = createEmptyVNode;
        target._u = resolveScopedSlots;
        target._g = bindObjectListeners;
        target._d = bindDynamicKeys;
        target._p = prependModifier;
      }

      /*  */

      function FunctionalRenderContext(
        data,
        props,
        children,
        parent,
        Ctor,
      ) {
        const this$1 = this;

        const { options } = Ctor;
        // ensure the createElement function in functional components
        // gets a unique context - this is necessary for correct named slot check
        let contextVm;
        if (hasOwn(parent, '_uid')) {
          contextVm = Object.create(parent);
          // $flow-disable-line
          contextVm._original = parent;
        } else {
          // the context vm passed in is a functional context as well.
          // in this case we want to make sure we are able to get a hold to the
          // real context instance.
          contextVm = parent;
          // $flow-disable-line
          parent = parent._original;
        }
        const isCompiled = isTrue(options._compiled);
        const needNormalization = !isCompiled;

        this.data = data;
        this.props = props;
        this.children = children;
        this.parent = parent;
        this.listeners = data.on || emptyObject;
        this.injections = resolveInject(options.inject, parent);
        this.slots = function () {
          if (!this$1.$slots) {
            normalizeScopedSlots(
              data.scopedSlots,
              this$1.$slots = resolveSlots(children, parent),
            );
          }
          return this$1.$slots;
        };

        Object.defineProperty(this, 'scopedSlots', ({
          enumerable: true,
          get: function get() {
            return normalizeScopedSlots(data.scopedSlots, this.slots());
          },
        }));

        // support for compiled functional template
        if (isCompiled) {
          // exposing $options for renderStatic()
          this.$options = options;
          // pre-resolve slots for renderSlot()
          this.$slots = this.slots();
          this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
        }

        if (options._scopeId) {
          this._c = function (a, b, c, d) {
            const vnode = createElement(contextVm, a, b, c, d, needNormalization);
            if (vnode && !Array.isArray(vnode)) {
              vnode.fnScopeId = options._scopeId;
              vnode.fnContext = parent;
            }
            return vnode;
          };
        } else {
          this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
        }
      }

      installRenderHelpers(FunctionalRenderContext.prototype);

      function createFunctionalComponent(
        Ctor,
        propsData,
        data,
        contextVm,
        children,
      ) {
        const { options } = Ctor;
        const props = {};
        const propOptions = options.props;
        if (isDef(propOptions)) {
          for (const key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
          }
        } else {
          if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
          if (isDef(data.props)) { mergeProps(props, data.props); }
        }

        const renderContext = new FunctionalRenderContext(
          data,
          props,
          children,
          contextVm,
          Ctor,
        );

        const vnode = options.render.call(null, renderContext._c, renderContext);

        if (vnode instanceof VNode) {
          return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
        } if (Array.isArray(vnode)) {
          const vnodes = normalizeChildren(vnode) || [];
          const res = new Array(vnodes.length);
          for (let i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
          }
          return res;
        }
      }

      function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
        // #7817 clone node before setting fnContext, otherwise if the node is reused
        // (e.g. it was from a cached normal slot) the fnContext causes named slots
        // that should not be matched to match.
        const clone = cloneVNode(vnode);
        clone.fnContext = contextVm;
        clone.fnOptions = options;
        if (true) {
          (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
        }
        if (data.slot) {
          (clone.data || (clone.data = {})).slot = data.slot;
        }
        return clone;
      }

      function mergeProps(to, from) {
        for (const key in from) {
          to[camelize(key)] = from[key];
        }
      }

      /*  */

      /*  */

      /*  */

      /*  */

      // inline hooks to be invoked on component VNodes during patch
      var componentVNodeHooks = {
        init: function init(vnode, hydrating) {
          if (
            vnode.componentInstance
      && !vnode.componentInstance._isDestroyed
      && vnode.data.keepAlive
          ) {
            // kept-alive components, treat as a patch
            const mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
          } else {
            const child = vnode.componentInstance = createComponentInstanceForVnode(
              vnode,
              activeInstance,
            );
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
          }
        },

        prepatch: function prepatch(oldVnode, vnode) {
          const options = vnode.componentOptions;
          const child = vnode.componentInstance = oldVnode.componentInstance;
          updateChildComponent(
            child,
            options.propsData, // updated props
            options.listeners, // updated listeners
            vnode, // new parent vnode
            options.children, // new children
          );
        },

        insert: function insert(vnode) {
          const { context } = vnode;
          const { componentInstance } = vnode;
          if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook(componentInstance, 'mounted');
          }
          if (vnode.data.keepAlive) {
            if (context._isMounted) {
              // vue-router#1212
              // During updates, a kept-alive component's child components may
              // change, so directly walking the tree here may call activated hooks
              // on incorrect children. Instead we push them into a queue which will
              // be processed after the whole patch process ended.
              queueActivatedComponent(componentInstance);
            } else {
              activateChildComponent(componentInstance, true /* direct */);
            }
          }
        },

        destroy: function destroy(vnode) {
          const { componentInstance } = vnode;
          if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
              componentInstance.$destroy();
            } else {
              deactivateChildComponent(componentInstance, true /* direct */);
            }
          }
        },
      };

      const hooksToMerge = Object.keys(componentVNodeHooks);

      function createComponent(
        Ctor,
        data,
        context,
        children,
        tag,
      ) {
        if (isUndef(Ctor)) {
          return;
        }

        const baseCtor = context.$options._base;

        // plain options object: turn it into a constructor
        if (isObject(Ctor)) {
          Ctor = baseCtor.extend(Ctor);
        }

        // if at this stage it's not a constructor or an async component factory,
        // reject.
        if (typeof Ctor !== 'function') {
          if (true) {
            warn((`Invalid Component definition: ${String(Ctor)}`), context);
          }
          return;
        }

        // async component
        let asyncFactory;
        if (isUndef(Ctor.cid)) {
          asyncFactory = Ctor;
          Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
          if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(
              asyncFactory,
              data,
              context,
              children,
              tag,
            );
          }
        }

        data = data || {};

        // resolve constructor options in case global mixins are applied after
        // component constructor creation
        resolveConstructorOptions(Ctor);

        // transform component v-model data into props & events
        if (isDef(data.model)) {
          transformModel(Ctor.options, data);
        }

        // extract props
        const propsData = extractPropsFromVNodeData(data, Ctor, tag);

        // functional component
        if (isTrue(Ctor.options.functional)) {
          return createFunctionalComponent(Ctor, propsData, data, context, children);
        }

        // extract listeners, since these needs to be treated as
        // child component listeners instead of DOM listeners
        const listeners = data.on;
        // replace with listeners with .native modifier
        // so it gets processed during parent component patch.
        data.on = data.nativeOn;

        if (isTrue(Ctor.options.abstract)) {
          // abstract components do not keep anything
          // other than props & listeners & slot

          // work around flow
          const { slot } = data;
          data = {};
          if (slot) {
            data.slot = slot;
          }
        }

        // install component management hooks onto the placeholder node
        installComponentHooks(data);

        // return a placeholder vnode
        const name = Ctor.options.name || tag;
        const vnode = new VNode(
          (`vue-component-${Ctor.cid}${name ? (`-${name}`) : ''}`),
          data, undefined, undefined, undefined, context,
          {
            Ctor, propsData, listeners, tag, children,
          },
          asyncFactory,
        );

        return vnode;
      }

      function createComponentInstanceForVnode(
        vnode, // we know it's MountedComponentVNode but flow doesn't
        parent, // activeInstance in lifecycle state
      ) {
        const options = {
          _isComponent: true,
          _parentVnode: vnode,
          parent,
        };
        // check inline-template render functions
        const { inlineTemplate } = vnode.data;
        if (isDef(inlineTemplate)) {
          options.render = inlineTemplate.render;
          options.staticRenderFns = inlineTemplate.staticRenderFns;
        }
        return new vnode.componentOptions.Ctor(options);
      }

      function installComponentHooks(data) {
        const hooks = data.hook || (data.hook = {});
        for (let i = 0; i < hooksToMerge.length; i++) {
          const key = hooksToMerge[i];
          const existing = hooks[key];
          const toMerge = componentVNodeHooks[key];
          if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
          }
        }
      }

      function mergeHook$1(f1, f2) {
        const merged = function (a, b) {
          // flow complains about extra args which is why we use any
          f1(a, b);
          f2(a, b);
        };
        merged._merged = true;
        return merged;
      }

      // transform component v-model info (value and callback) into
      // prop and event handler respectively.
      function transformModel(options, data) {
        const prop = (options.model && options.model.prop) || 'value';
        const event = (options.model && options.model.event) || 'input';
        (data.attrs || (data.attrs = {}))[prop] = data.model.value;
        const on = data.on || (data.on = {});
        const existing = on[event];
        const { callback } = data.model;
        if (isDef(existing)) {
          if (
            Array.isArray(existing)
              ? existing.indexOf(callback) === -1
              : existing !== callback
          ) {
            on[event] = [callback].concat(existing);
          }
        } else {
          on[event] = callback;
        }
      }

      /*  */

      const SIMPLE_NORMALIZE = 1;
      const ALWAYS_NORMALIZE = 2;

      // wrapper function for providing a more flexible interface
      // without getting yelled at by flow
      function createElement(
        context,
        tag,
        data,
        children,
        normalizationType,
        alwaysNormalize,
      ) {
        if (Array.isArray(data) || isPrimitive(data)) {
          normalizationType = children;
          children = data;
          data = undefined;
        }
        if (isTrue(alwaysNormalize)) {
          normalizationType = ALWAYS_NORMALIZE;
        }
        return _createElement(context, tag, data, children, normalizationType);
      }

      function _createElement(
        context,
        tag,
        data,
        children,
        normalizationType,
      ) {
        if (isDef(data) && isDef((data).__ob__)) {
          true && warn(
            `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n`
      + 'Always create fresh vnode data objects in each render!',
            context,
          );
          return createEmptyVNode();
        }
        // object syntax in v-bind
        if (isDef(data) && isDef(data.is)) {
          tag = data.is;
        }
        if (!tag) {
          // in case of component :is set to falsy value
          return createEmptyVNode();
        }
        // warn against non-primitive key
        if (true
    && isDef(data) && isDef(data.key) && !isPrimitive(data.key)
        ) {
          {
            warn(
              'Avoid using non-primitive value as key, '
        + 'use string/number value instead.',
              context,
            );
          }
        }
        // support single function children as default scoped slot
        if (Array.isArray(children)
    && typeof children[0] === 'function'
        ) {
          data = data || {};
          data.scopedSlots = { default: children[0] };
          children.length = 0;
        }
        if (normalizationType === ALWAYS_NORMALIZE) {
          children = normalizeChildren(children);
        } else if (normalizationType === SIMPLE_NORMALIZE) {
          children = simpleNormalizeChildren(children);
        }
        let vnode; let
          ns;
        if (typeof tag === 'string') {
          let Ctor;
          ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
          if (config.isReservedTag(tag)) {
            // platform built-in elements
            vnode = new VNode(
              config.parsePlatformTagName(tag), data, children,
              undefined, undefined, context,
            );
          } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
          } else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(
              tag, data, children,
              undefined, undefined, context,
            );
          }
        } else {
          // direct component options / constructor
          vnode = createComponent(tag, data, context, children);
        }
        if (Array.isArray(vnode)) {
          return vnode;
        } if (isDef(vnode)) {
          if (isDef(ns)) { applyNS(vnode, ns); }
          if (isDef(data)) { registerDeepBindings(data); }
          return vnode;
        }
        return createEmptyVNode();
      }

      function applyNS(vnode, ns, force) {
        vnode.ns = ns;
        if (vnode.tag === 'foreignObject') {
          // use default namespace inside foreignObject
          ns = undefined;
          force = true;
        }
        if (isDef(vnode.children)) {
          for (let i = 0, l = vnode.children.length; i < l; i++) {
            const child = vnode.children[i];
            if (isDef(child.tag) && (
              isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
              applyNS(child, ns, force);
            }
          }
        }
      }

      // ref #5318
      // necessary to ensure parent re-render when deep bindings like :style and
      // :class are used on slot nodes
      function registerDeepBindings(data) {
        if (isObject(data.style)) {
          traverse(data.style);
        }
        if (isObject(data.class)) {
          traverse(data.class);
        }
      }

      /*  */

      function initRender(vm) {
        vm._vnode = null; // the root of the child tree
        vm._staticTrees = null; // v-once cached trees
        const options = vm.$options;
        const parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
        const renderContext = parentVnode && parentVnode.context;
        vm.$slots = resolveSlots(options._renderChildren, renderContext);
        vm.$scopedSlots = emptyObject;
        // bind the createElement fn to this instance
        // so that we get proper render context inside it.
        // args order: tag, data, children, normalizationType, alwaysNormalize
        // internal version is used by render functions compiled from templates
        vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
        // normalization is always applied for the public version, used in
        // user-written render functions.
        vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

        // $attrs & $listeners are exposed for easier HOC creation.
        // they need to be reactive so that HOCs using them are always updated
        const parentData = parentVnode && parentVnode.data;

        /* istanbul ignore else */
        if (true) {
          defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, () => {
            !isUpdatingChildComponent && warn('$attrs is readonly.', vm);
          }, true);
          defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, () => {
            !isUpdatingChildComponent && warn('$listeners is readonly.', vm);
          }, true);
        } else {}
      }

      let currentRenderingInstance = null;

      function renderMixin(Vue) {
        // install runtime convenience helpers
        installRenderHelpers(Vue.prototype);

        Vue.prototype.$nextTick = function (fn) {
          return nextTick(fn, this);
        };

        Vue.prototype._render = function () {
          const vm = this;
          const ref = vm.$options;
          const { render } = ref;
          const { _parentVnode } = ref;

          if (_parentVnode) {
            vm.$scopedSlots = normalizeScopedSlots(
              _parentVnode.data.scopedSlots,
              vm.$slots,
              vm.$scopedSlots,
            );
          }

          // set parent vnode. this allows render functions to have access
          // to the data on the placeholder node.
          vm.$vnode = _parentVnode;
          // render self
          let vnode;
          try {
            // There's no need to maintain a stack becaues all render fns are called
            // separately from one another. Nested component's render fns are called
            // when parent component is patched.
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
          } catch (e) {
            handleError(e, vm, 'render');
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if (true && vm.$options.renderError) {
              try {
                vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
              } catch (e) {
                handleError(e, vm, 'renderError');
                vnode = vm._vnode;
              }
            } else {
              vnode = vm._vnode;
            }
          } finally {
            currentRenderingInstance = null;
          }
          // if the returned array contains only a single node, allow it
          if (Array.isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
          }
          // return empty vnode in case the render function errored out
          if (!(vnode instanceof VNode)) {
            if (true && Array.isArray(vnode)) {
              warn(
                'Multiple root nodes returned from render function. Render function '
          + 'should return a single root node.',
                vm,
              );
            }
            vnode = createEmptyVNode();
          }
          // set parent
          vnode.parent = _parentVnode;
          return vnode;
        };
      }

      /*  */

      function ensureCtor(comp, base) {
        if (
          comp.__esModule
    || (hasSymbol && comp[Symbol.toStringTag] === 'Module')
        ) {
          comp = comp.default;
        }
        return isObject(comp)
          ? base.extend(comp)
          : comp;
      }

      function createAsyncPlaceholder(
        factory,
        data,
        context,
        children,
        tag,
      ) {
        const node = createEmptyVNode();
        node.asyncFactory = factory;
        node.asyncMeta = {
          data, context, children, tag,
        };
        return node;
      }

      function resolveAsyncComponent(
        factory,
        baseCtor,
      ) {
        if (isTrue(factory.error) && isDef(factory.errorComp)) {
          return factory.errorComp;
        }

        if (isDef(factory.resolved)) {
          return factory.resolved;
        }

        const owner = currentRenderingInstance;
        if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
          // already pending
          factory.owners.push(owner);
        }

        if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
          return factory.loadingComp;
        }

        if (owner && !isDef(factory.owners)) {
          const owners = factory.owners = [owner];
          let sync = true;
          let timerLoading = null;
          let timerTimeout = null;
          (owner).$on('hook:destroyed', () => remove(owners, owner));

          const forceRender = function (renderCompleted) {
            for (let i = 0, l = owners.length; i < l; i++) {
              (owners[i]).$forceUpdate();
            }

            if (renderCompleted) {
              owners.length = 0;
              if (timerLoading !== null) {
                clearTimeout(timerLoading);
                timerLoading = null;
              }
              if (timerTimeout !== null) {
                clearTimeout(timerTimeout);
                timerTimeout = null;
              }
            }
          };

          const resolve = once((res) => {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync) {
              forceRender(true);
            } else {
              owners.length = 0;
            }
          });

          const reject = once((reason) => {
            true && warn(
              `Failed to resolve async component: ${String(factory)
              }${reason ? (`\nReason: ${reason}`) : ''}`,
            );
            if (isDef(factory.errorComp)) {
              factory.error = true;
              forceRender(true);
            }
          });

          const res = factory(resolve, reject);

          if (isObject(res)) {
            if (isPromise(res)) {
              // () => Promise
              if (isUndef(factory.resolved)) {
                res.then(resolve, reject);
              }
            } else if (isPromise(res.component)) {
              res.component.then(resolve, reject);

              if (isDef(res.error)) {
                factory.errorComp = ensureCtor(res.error, baseCtor);
              }

              if (isDef(res.loading)) {
                factory.loadingComp = ensureCtor(res.loading, baseCtor);
                if (res.delay === 0) {
                  factory.loading = true;
                } else {
                  timerLoading = setTimeout(() => {
                    timerLoading = null;
                    if (isUndef(factory.resolved) && isUndef(factory.error)) {
                      factory.loading = true;
                      forceRender(false);
                    }
                  }, res.delay || 200);
                }
              }

              if (isDef(res.timeout)) {
                timerTimeout = setTimeout(() => {
                  timerTimeout = null;
                  if (isUndef(factory.resolved)) {
                    reject(
                      true
                        ? (`timeout (${res.timeout}ms)`)
                        : undefined,
                    );
                  }
                }, res.timeout);
              }
            }
          }

          sync = false;
          // return in case resolved synchronously
          return factory.loading
            ? factory.loadingComp
            : factory.resolved;
        }
      }

      /*  */

      function isAsyncPlaceholder(node) {
        return node.isComment && node.asyncFactory;
      }

      /*  */

      function getFirstComponentChild(children) {
        if (Array.isArray(children)) {
          for (let i = 0; i < children.length; i++) {
            const c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
              return c;
            }
          }
        }
      }

      /*  */

      /*  */

      function initEvents(vm) {
        vm._events = Object.create(null);
        vm._hasHookEvent = false;
        // init parent attached events
        const listeners = vm.$options._parentListeners;
        if (listeners) {
          updateComponentListeners(vm, listeners);
        }
      }

      let target;

      function add(event, fn) {
        target.$on(event, fn);
      }

      function remove$1(event, fn) {
        target.$off(event, fn);
      }

      function createOnceHandler(event, fn) {
        const _target = target;
        return function onceHandler() {
          const res = fn.apply(null, arguments);
          if (res !== null) {
            _target.$off(event, onceHandler);
          }
        };
      }

      function updateComponentListeners(
        vm,
        listeners,
        oldListeners,
      ) {
        target = vm;
        updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
        target = undefined;
      }

      function eventsMixin(Vue) {
        const hookRE = /^hook:/;
        Vue.prototype.$on = function (event, fn) {
          const vm = this;
          if (Array.isArray(event)) {
            for (let i = 0, l = event.length; i < l; i++) {
              vm.$on(event[i], fn);
            }
          } else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
              vm._hasHookEvent = true;
            }
          }
          return vm;
        };

        Vue.prototype.$once = function (event, fn) {
          const vm = this;
          function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
          }
          on.fn = fn;
          vm.$on(event, on);
          return vm;
        };

        Vue.prototype.$off = function (event, fn) {
          const vm = this;
          // all
          if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
          }
          // array of events
          if (Array.isArray(event)) {
            for (let i$1 = 0, l = event.length; i$1 < l; i$1++) {
              vm.$off(event[i$1], fn);
            }
            return vm;
          }
          // specific event
          const cbs = vm._events[event];
          if (!cbs) {
            return vm;
          }
          if (!fn) {
            vm._events[event] = null;
            return vm;
          }
          // specific handler
          let cb;
          let i = cbs.length;
          while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
              cbs.splice(i, 1);
              break;
            }
          }
          return vm;
        };

        Vue.prototype.$emit = function (event) {
          const vm = this;
          if (true) {
            const lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
              tip(
                `Event "${lowerCaseEvent}" is emitted in component ${
                  formatComponentName(vm)} but the handler is registered for "${event}". `
          + 'Note that HTML attributes are case-insensitive and you cannot use '
          + 'v-on to listen to camelCase events when using in-DOM templates. '
          + `You should probably use "${hyphenate(event)}" instead of "${event}".`,
              );
            }
          }
          let cbs = vm._events[event];
          if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            const args = toArray(arguments, 1);
            const info = `event handler for "${event}"`;
            for (let i = 0, l = cbs.length; i < l; i++) {
              invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
          }
          return vm;
        };
      }

      /*  */

      var activeInstance = null;
      var isUpdatingChildComponent = false;

      function setActiveInstance(vm) {
        const prevActiveInstance = activeInstance;
        activeInstance = vm;
        return function () {
          activeInstance = prevActiveInstance;
        };
      }

      function initLifecycle(vm) {
        const options = vm.$options;

        // locate first non-abstract parent
        let { parent } = options;
        if (parent && !options.abstract) {
          while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
          }
          parent.$children.push(vm);
        }

        vm.$parent = parent;
        vm.$root = parent ? parent.$root : vm;

        vm.$children = [];
        vm.$refs = {};

        vm._watcher = null;
        vm._inactive = null;
        vm._directInactive = false;
        vm._isMounted = false;
        vm._isDestroyed = false;
        vm._isBeingDestroyed = false;
      }

      function lifecycleMixin(Vue) {
        Vue.prototype._update = function (vnode, hydrating) {
          const vm = this;
          const prevEl = vm.$el;
          const prevVnode = vm._vnode;
          const restoreActiveInstance = setActiveInstance(vm);
          vm._vnode = vnode;
          // Vue.prototype.__patch__ is injected in entry points
          // based on the rendering backend used.
          if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
          } else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
          }
          restoreActiveInstance();
          // update __vue__ reference
          if (prevEl) {
            prevEl.__vue__ = null;
          }
          if (vm.$el) {
            vm.$el.__vue__ = vm;
          }
          // if parent is an HOC, update its $el as well
          if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
            vm.$parent.$el = vm.$el;
          }
          // updated hook is called by the scheduler to ensure that children are
          // updated in a parent's updated hook.
        };

        Vue.prototype.$forceUpdate = function () {
          const vm = this;
          if (vm._watcher) {
            vm._watcher.update();
          }
        };

        Vue.prototype.$destroy = function () {
          const vm = this;
          if (vm._isBeingDestroyed) {
            return;
          }
          callHook(vm, 'beforeDestroy');
          vm._isBeingDestroyed = true;
          // remove self from parent
          const parent = vm.$parent;
          if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove(parent.$children, vm);
          }
          // teardown watchers
          if (vm._watcher) {
            vm._watcher.teardown();
          }
          let i = vm._watchers.length;
          while (i--) {
            vm._watchers[i].teardown();
          }
          // remove reference from data ob
          // frozen object may not have observer.
          if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
          }
          // call the last hook...
          vm._isDestroyed = true;
          // invoke destroy hooks on current rendered tree
          vm.__patch__(vm._vnode, null);
          // fire destroyed hook
          callHook(vm, 'destroyed');
          // turn off all instance listeners.
          vm.$off();
          // remove __vue__ reference
          if (vm.$el) {
            vm.$el.__vue__ = null;
          }
          // release circular reference (#6759)
          if (vm.$vnode) {
            vm.$vnode.parent = null;
          }
        };
      }

      function updateChildComponent(
        vm,
        propsData,
        listeners,
        parentVnode,
        renderChildren,
      ) {
        if (true) {
          isUpdatingChildComponent = true;
        }

        // determine whether component has slot children
        // we need to do this before overwriting $options._renderChildren.

        // check if there are dynamic scopedSlots (hand-written or compiled but with
        // dynamic slot names). Static scoped slots compiled from template has the
        // "$stable" marker.
        const newScopedSlots = parentVnode.data.scopedSlots;
        const oldScopedSlots = vm.$scopedSlots;
        const hasDynamicScopedSlot = !!(
          (newScopedSlots && !newScopedSlots.$stable)
    || (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable)
    || (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
        );

        // Any static slot children from the parent may have changed during parent's
        // update. Dynamic scoped slots may also have changed. In such cases, a forced
        // update is necessary to ensure correctness.
        const needsForceUpdate = !!(
          renderChildren // has new static slots
    || vm.$options._renderChildren // has old static slots
    || hasDynamicScopedSlot
        );

        vm.$options._parentVnode = parentVnode;
        vm.$vnode = parentVnode; // update vm's placeholder node without re-render

        if (vm._vnode) { // update child tree's parent
          vm._vnode.parent = parentVnode;
        }
        vm.$options._renderChildren = renderChildren;

        // update $attrs and $listeners hash
        // these are also reactive so they may trigger child update if the child
        // used them during render
        vm.$attrs = parentVnode.data.attrs || emptyObject;
        vm.$listeners = listeners || emptyObject;

        // update props
        if (propsData && vm.$options.props) {
          toggleObserving(false);
          const props = vm._props;
          const propKeys = vm.$options._propKeys || [];
          for (let i = 0; i < propKeys.length; i++) {
            const key = propKeys[i];
            const propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
          }
          toggleObserving(true);
          // keep a copy of raw propsData
          vm.$options.propsData = propsData;
        }

        // update listeners
        listeners = listeners || emptyObject;
        const oldListeners = vm.$options._parentListeners;
        vm.$options._parentListeners = listeners;
        updateComponentListeners(vm, listeners, oldListeners);

        // resolve slots + force update if has children
        if (needsForceUpdate) {
          vm.$slots = resolveSlots(renderChildren, parentVnode.context);
          vm.$forceUpdate();
        }

        if (true) {
          isUpdatingChildComponent = false;
        }
      }

      function isInInactiveTree(vm) {
        while (vm && (vm = vm.$parent)) {
          if (vm._inactive) { return true; }
        }
        return false;
      }

      function activateChildComponent(vm, direct) {
        if (direct) {
          vm._directInactive = false;
          if (isInInactiveTree(vm)) {
            return;
          }
        } else if (vm._directInactive) {
          return;
        }
        if (vm._inactive || vm._inactive === null) {
          vm._inactive = false;
          for (let i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
          }
          callHook(vm, 'activated');
        }
      }

      function deactivateChildComponent(vm, direct) {
        if (direct) {
          vm._directInactive = true;
          if (isInInactiveTree(vm)) {
            return;
          }
        }
        if (!vm._inactive) {
          vm._inactive = true;
          for (let i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
          }
          callHook(vm, 'deactivated');
        }
      }

      function callHook(vm, hook) {
        // #7573 disable dep collection when invoking lifecycle hooks
        pushTarget();
        const handlers = vm.$options[hook];
        const info = `${hook} hook`;
        if (handlers) {
          for (let i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, null, vm, info);
          }
        }
        if (vm._hasHookEvent) {
          vm.$emit(`hook:${hook}`);
        }
        popTarget();
      }

      /*  */

      const MAX_UPDATE_COUNT = 100;

      const queue = [];
      const activatedChildren = [];
      let has = {};
      let circular = {};
      let waiting = false;
      let flushing = false;
      let index = 0;

      /**
 * Reset the scheduler's state.
 */
      function resetSchedulerState() {
        index = queue.length = activatedChildren.length = 0;
        has = {};
        if (true) {
          circular = {};
        }
        waiting = flushing = false;
      }

      // Async edge case #6566 requires saving the timestamp when event listeners are
      // attached. However, calling performance.now() has a perf overhead especially
      // if the page has thousands of event listeners. Instead, we take a timestamp
      // every time the scheduler flushes and use that for all event listeners
      // attached during that flush.
      let currentFlushTimestamp = 0;

      // Async edge case fix requires storing an event listener's attach timestamp.
      let getNow = Date.now;

      // Determine what event timestamp the browser is using. Annoyingly, the
      // timestamp can either be hi-res (relative to page load) or low-res
      // (relative to UNIX epoch), so in order to compare time we have to use the
      // same timestamp type when saving the flush timestamp.
      // All IE versions use low-res event timestamps, and have problematic clock
      // implementations (#9632)
      if (inBrowser && !isIE) {
        const { performance } = window;
        if (
          performance
    && typeof performance.now === 'function'
    && getNow() > document.createEvent('Event').timeStamp
        ) {
          // if the event timestamp, although evaluated AFTER the Date.now(), is
          // smaller than it, it means the event is using a hi-res timestamp,
          // and we need to use the hi-res version for event listener timestamps as
          // well.
          getNow = function () { return performance.now(); };
        }
      }

      /**
 * Flush both queues and run the watchers.
 */
      function flushSchedulerQueue() {
        currentFlushTimestamp = getNow();
        flushing = true;
        let watcher; let
          id;

        // Sort queue before flush.
        // This ensures that:
        // 1. Components are updated from parent to child. (because parent is always
        //    created before the child)
        // 2. A component's user watchers are run before its render watcher (because
        //    user watchers are created before the render watcher)
        // 3. If a component is destroyed during a parent component's watcher run,
        //    its watchers can be skipped.
        queue.sort((a, b) => a.id - b.id);

        // do not cache length because more watchers might be pushed
        // as we run existing watchers
        for (index = 0; index < queue.length; index++) {
          watcher = queue[index];
          if (watcher.before) {
            watcher.before();
          }
          id = watcher.id;
          has[id] = null;
          watcher.run();
          // in dev build, check and stop circular updates.
          if (true && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
              warn(
                `You may have an infinite update loop ${
                  watcher.user
                    ? (`in watcher with expression "${watcher.expression}"`)
                    : 'in a component render function.'}`,
                watcher.vm,
              );
              break;
            }
          }
        }

        // keep copies of post queues before resetting state
        const activatedQueue = activatedChildren.slice();
        const updatedQueue = queue.slice();

        resetSchedulerState();

        // call component updated and activated hooks
        callActivatedHooks(activatedQueue);
        callUpdatedHooks(updatedQueue);

        // devtool hook
        /* istanbul ignore if */
        if (devtools && config.devtools) {
          devtools.emit('flush');
        }
      }

      function callUpdatedHooks(queue) {
        let i = queue.length;
        while (i--) {
          const watcher = queue[i];
          const { vm } = watcher;
          if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook(vm, 'updated');
          }
        }
      }

      /**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
      function queueActivatedComponent(vm) {
        // setting _inactive to false here so that a render function can
        // rely on checking whether it's in an inactive tree (e.g. router-view)
        vm._inactive = false;
        activatedChildren.push(vm);
      }

      function callActivatedHooks(queue) {
        for (let i = 0; i < queue.length; i++) {
          queue[i]._inactive = true;
          activateChildComponent(queue[i], true /* true */);
        }
      }

      /**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
      function queueWatcher(watcher) {
        const { id } = watcher;
        if (has[id] == null) {
          has[id] = true;
          if (!flushing) {
            queue.push(watcher);
          } else {
            // if already flushing, splice the watcher based on its id
            // if already past its id, it will be run next immediately.
            let i = queue.length - 1;
            while (i > index && queue[i].id > watcher.id) {
              i--;
            }
            queue.splice(i + 1, 0, watcher);
          }
          // queue the flush
          if (!waiting) {
            waiting = true;

            if (true && !config.async) {
              flushSchedulerQueue();
              return;
            }
            nextTick(flushSchedulerQueue);
          }
        }
      }

      /*  */


      let uid$2 = 0;

      /**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
      const Watcher = function Watcher(
        vm,
        expOrFn,
        cb,
        options,
        isRenderWatcher,
      ) {
        this.vm = vm;
        if (isRenderWatcher) {
          vm._watcher = this;
        }
        vm._watchers.push(this);
        // options
        if (options) {
          this.deep = !!options.deep;
          this.user = !!options.user;
          this.lazy = !!options.lazy;
          this.sync = !!options.sync;
          this.before = options.before;
        } else {
          this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$2; // uid for batching
        this.active = true;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = true
          ? expOrFn.toString()
          : undefined;
        // parse expression for getter
        if (typeof expOrFn === 'function') {
          this.getter = expOrFn;
        } else {
          this.getter = parsePath(expOrFn);
          if (!this.getter) {
            this.getter = noop;
            true && warn(
              `Failed watching path: "${expOrFn}" `
        + 'Watcher only accepts simple dot-delimited paths. '
        + 'For full control, use a function instead.',
              vm,
            );
          }
        }
        this.value = this.lazy
          ? undefined
          : this.get();
      };

      /**
 * Evaluate the getter, and re-collect dependencies.
 */
      Watcher.prototype.get = function get() {
        pushTarget(this);
        let value;
        const { vm } = this;
        try {
          value = this.getter.call(vm, vm);
        } catch (e) {
          if (this.user) {
            handleError(e, vm, (`getter for watcher "${this.expression}"`));
          } else {
            throw e;
          }
        } finally {
          // "touch" every property so they are all tracked as
          // dependencies for deep watching
          if (this.deep) {
            traverse(value);
          }
          popTarget();
          this.cleanupDeps();
        }
        return value;
      };

      /**
 * Add a dependency to this directive.
 */
      Watcher.prototype.addDep = function addDep(dep) {
        const { id } = dep;
        if (!this.newDepIds.has(id)) {
          this.newDepIds.add(id);
          this.newDeps.push(dep);
          if (!this.depIds.has(id)) {
            dep.addSub(this);
          }
        }
      };

      /**
 * Clean up for dependency collection.
 */
      Watcher.prototype.cleanupDeps = function cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
          const dep = this.deps[i];
          if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
          }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
      };

      /**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
      Watcher.prototype.update = function update() {
        /* istanbul ignore else */
        if (this.lazy) {
          this.dirty = true;
        } else if (this.sync) {
          this.run();
        } else {
          queueWatcher(this);
        }
      };

      /**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
      Watcher.prototype.run = function run() {
        if (this.active) {
          const value = this.get();
          if (
            value !== this.value
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      || isObject(value)
      || this.deep
          ) {
            // set new value
            const oldValue = this.value;
            this.value = value;
            if (this.user) {
              try {
                this.cb.call(this.vm, value, oldValue);
              } catch (e) {
                handleError(e, this.vm, (`callback for watcher "${this.expression}"`));
              }
            } else {
              this.cb.call(this.vm, value, oldValue);
            }
          }
        }
      };

      /**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
      Watcher.prototype.evaluate = function evaluate() {
        this.value = this.get();
        this.dirty = false;
      };

      /**
 * Depend on all deps collected by this watcher.
 */
      Watcher.prototype.depend = function depend() {
        let i = this.deps.length;
        while (i--) {
          this.deps[i].depend();
        }
      };

      /**
 * Remove self from all dependencies' subscriber list.
 */
      Watcher.prototype.teardown = function teardown() {
        if (this.active) {
          // remove self from vm's watcher list
          // this is a somewhat expensive operation so we skip it
          // if the vm is being destroyed.
          if (!this.vm._isBeingDestroyed) {
            remove(this.vm._watchers, this);
          }
          let i = this.deps.length;
          while (i--) {
            this.deps[i].removeSub(this);
          }
          this.active = false;
        }
      };

      /*  */

      const sharedPropertyDefinition = {
        enumerable: true,
        configurable: true,
        get: noop,
        set: noop,
      };

      function proxy(target, sourceKey, key) {
        sharedPropertyDefinition.get = function proxyGetter() {
          return this[sourceKey][key];
        };
        sharedPropertyDefinition.set = function proxySetter(val) {
          this[sourceKey][key] = val;
        };
        Object.defineProperty(target, key, sharedPropertyDefinition);
      }

      function initState(vm) {
        vm._watchers = [];
        const opts = vm.$options;
        if (opts.props) { initProps(vm, opts.props); }
        if (opts.methods) { initMethods(vm, opts.methods); }
        if (opts.data) {
          initData(vm);
        } else {
          observe(vm._data = {}, true /* asRootData */);
        }
        if (opts.computed) { initComputed(vm, opts.computed); }
        if (opts.watch && opts.watch !== nativeWatch) {
          initWatch(vm, opts.watch);
        }
      }

      function initProps(vm, propsOptions) {
        const propsData = vm.$options.propsData || {};
        const props = vm._props = {};
        // cache prop keys so that future props updates can iterate using Array
        // instead of dynamic object key enumeration.
        const keys = vm.$options._propKeys = [];
        const isRoot = !vm.$parent;
        // root instance props should be converted
        if (!isRoot) {
          toggleObserving(false);
        }
        const loop = function (key) {
          keys.push(key);
          const value = validateProp(key, propsOptions, propsData, vm);
          /* istanbul ignore else */
          if (true) {
            const hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey)
          || config.isReservedAttr(hyphenatedKey)) {
              warn(
                (`"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`),
                vm,
              );
            }
            defineReactive$$1(props, key, value, () => {
              if (!isRoot && !isUpdatingChildComponent) {
                {
                  if (vm.mpHost === 'mp-baidu') { // 百度 observer 在 setData callback 之后触发，直接忽略该 warn
                    return;
                  }
                  // fixed by xxxxxx __next_tick_pending,uni://form-field 时不告警
                  if (vm._getFormData || (vm.$parent && vm.$parent.__next_tick_pending)) {
                    return;
                  }
                }
                warn(
                  `${'Avoid mutating a prop directly since the value will be '
            + 'overwritten whenever the parent component re-renders. '
            + "Instead, use a data or computed property based on the prop's "
            + 'value. Prop being mutated: "'}${key}"`,
                  vm,
                );
              }
            });
          } else {}
          // static props are already proxied on the component's prototype
          // during Vue.extend(). We only need to proxy props defined at
          // instantiation here.
          if (!(key in vm)) {
            proxy(vm, '_props', key);
          }
        };

        for (const key in propsOptions) loop(key);
        toggleObserving(true);
      }

      function initData(vm) {
        let { data } = vm.$options;
        data = vm._data = typeof data === 'function'
          ? getData(data, vm)
          : data || {};
        if (!isPlainObject(data)) {
          data = {};
          true && warn(
            'data functions should return an object:\n'
      + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
            vm,
          );
        }
        // proxy data on instance
        const keys = Object.keys(data);
        const { props } = vm.$options;
        const { methods } = vm.$options;
        let i = keys.length;
        while (i--) {
          const key = keys[i];
          if (true) {
            if (methods && hasOwn(methods, key)) {
              warn(
                (`Method "${key}" has already been defined as a data property.`),
                vm,
              );
            }
          }
          if (props && hasOwn(props, key)) {
            true && warn(
              `The data property "${key}" is already declared as a prop. `
        + 'Use prop default value instead.',
              vm,
            );
          } else if (!isReserved(key)) {
            proxy(vm, '_data', key);
          }
        }
        // observe data
        observe(data, true /* asRootData */);
      }

      function getData(data, vm) {
        // #7573 disable dep collection when invoking data getters
        pushTarget();
        try {
          return data.call(vm, vm);
        } catch (e) {
          handleError(e, vm, 'data()');
          return {};
        } finally {
          popTarget();
        }
      }

      const computedWatcherOptions = { lazy: true };

      function initComputed(vm, computed) {
        // $flow-disable-line
        const watchers = vm._computedWatchers = Object.create(null);
        // computed properties are just getters during SSR
        const isSSR = isServerRendering();

        for (const key in computed) {
          const userDef = computed[key];
          const getter = typeof userDef === 'function' ? userDef : userDef.get;
          if (true && getter == null) {
            warn(
              (`Getter is missing for computed property "${key}".`),
              vm,
            );
          }

          if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(
              vm,
              getter || noop,
              noop,
              computedWatcherOptions,
            );
          }

          // component-defined computed properties are already defined on the
          // component prototype. We only need to define computed properties defined
          // at instantiation here.
          if (!(key in vm)) {
            defineComputed(vm, key, userDef);
          } else if (true) {
            if (key in vm.$data) {
              warn((`The computed property "${key}" is already defined in data.`), vm);
            } else if (vm.$options.props && key in vm.$options.props) {
              warn((`The computed property "${key}" is already defined as a prop.`), vm);
            }
          }
        }
      }

      function defineComputed(
        target,
        key,
        userDef,
      ) {
        const shouldCache = !isServerRendering();
        if (typeof userDef === 'function') {
          sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
          sharedPropertyDefinition.set = noop;
        } else {
          sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
              ? createComputedGetter(key)
              : createGetterInvoker(userDef.get)
            : noop;
          sharedPropertyDefinition.set = userDef.set || noop;
        }
        if (true
      && sharedPropertyDefinition.set === noop) {
          sharedPropertyDefinition.set = function () {
            warn(
              (`Computed property "${key}" was assigned to but it has no setter.`),
              this,
            );
          };
        }
        Object.defineProperty(target, key, sharedPropertyDefinition);
      }

      function createComputedGetter(key) {
        return function computedGetter() {
          const watcher = this._computedWatchers && this._computedWatchers[key];
          if (watcher) {
            if (watcher.dirty) {
              watcher.evaluate();
            }
            if (Dep.target) {
              watcher.depend();
            }
            return watcher.value;
          }
        };
      }

      function createGetterInvoker(fn) {
        return function computedGetter() {
          return fn.call(this, this);
        };
      }

      function initMethods(vm, methods) {
        const { props } = vm.$options;
        for (const key in methods) {
          if (true) {
            if (typeof methods[key] !== 'function') {
              warn(
                `Method "${key}" has type "${typeof methods[key]}" in the component definition. `
          + 'Did you reference the function correctly?',
                vm,
              );
            }
            if (props && hasOwn(props, key)) {
              warn(
                (`Method "${key}" has already been defined as a prop.`),
                vm,
              );
            }
            if ((key in vm) && isReserved(key)) {
              warn(
                `Method "${key}" conflicts with an existing Vue instance method. `
          + 'Avoid defining component methods that start with _ or $.',
              );
            }
          }
          vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
        }
      }

      function initWatch(vm, watch) {
        for (const key in watch) {
          const handler = watch[key];
          if (Array.isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
              createWatcher(vm, key, handler[i]);
            }
          } else {
            createWatcher(vm, key, handler);
          }
        }
      }

      function createWatcher(
        vm,
        expOrFn,
        handler,
        options,
      ) {
        if (isPlainObject(handler)) {
          options = handler;
          handler = handler.handler;
        }
        if (typeof handler === 'string') {
          handler = vm[handler];
        }
        return vm.$watch(expOrFn, handler, options);
      }

      function stateMixin(Vue) {
        // flow somehow has problems with directly declared definition object
        // when using Object.defineProperty, so we have to procedurally build up
        // the object here.
        const dataDef = {};
        dataDef.get = function () { return this._data; };
        const propsDef = {};
        propsDef.get = function () { return this._props; };
        if (true) {
          dataDef.set = function () {
            warn(
              'Avoid replacing instance root $data. '
        + 'Use nested data properties instead.',
              this,
            );
          };
          propsDef.set = function () {
            warn('$props is readonly.', this);
          };
        }
        Object.defineProperty(Vue.prototype, '$data', dataDef);
        Object.defineProperty(Vue.prototype, '$props', propsDef);

        Vue.prototype.$set = set;
        Vue.prototype.$delete = del;

        Vue.prototype.$watch = function (
          expOrFn,
          cb,
          options,
        ) {
          const vm = this;
          if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
          }
          options = options || {};
          options.user = true;
          const watcher = new Watcher(vm, expOrFn, cb, options);
          if (options.immediate) {
            try {
              cb.call(vm, watcher.value);
            } catch (error) {
              handleError(error, vm, (`callback for immediate watcher "${watcher.expression}"`));
            }
          }
          return function unwatchFn() {
            watcher.teardown();
          };
        };
      }

      /*  */

      let uid$3 = 0;

      function initMixin(Vue) {
        Vue.prototype._init = function (options) {
          const vm = this;
          // a uid
          vm._uid = uid$3++;

          let startTag; let
            endTag;
          /* istanbul ignore if */
          if (true && config.performance && mark) {
            startTag = `vue-perf-start:${vm._uid}`;
            endTag = `vue-perf-end:${vm._uid}`;
            mark(startTag);
          }

          // a flag to avoid this being observed
          vm._isVue = true;
          // merge options
          if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
          } else {
            vm.$options = mergeOptions(
              resolveConstructorOptions(vm.constructor),
              options || {},
              vm,
            );
          }
          /* istanbul ignore else */
          if (true) {
            initProxy(vm);
          } else {}
          // expose real self
          vm._self = vm;
          initLifecycle(vm);
          initEvents(vm);
          initRender(vm);
          callHook(vm, 'beforeCreate');
          vm.mpHost !== 'mp-toutiao' && initInjections(vm); // resolve injections before data/props
          initState(vm);
          vm.mpHost !== 'mp-toutiao' && initProvide(vm); // resolve provide after data/props
          vm.mpHost !== 'mp-toutiao' && callHook(vm, 'created');

          /* istanbul ignore if */
          if (true && config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure((`vue ${vm._name} init`), startTag, endTag);
          }

          if (vm.$options.el) {
            vm.$mount(vm.$options.el);
          }
        };
      }

      function initInternalComponent(vm, options) {
        const opts = vm.$options = Object.create(vm.constructor.options);
        // doing this because it's faster than dynamic enumeration.
        const parentVnode = options._parentVnode;
        opts.parent = options.parent;
        opts._parentVnode = parentVnode;

        const vnodeComponentOptions = parentVnode.componentOptions;
        opts.propsData = vnodeComponentOptions.propsData;
        opts._parentListeners = vnodeComponentOptions.listeners;
        opts._renderChildren = vnodeComponentOptions.children;
        opts._componentTag = vnodeComponentOptions.tag;

        if (options.render) {
          opts.render = options.render;
          opts.staticRenderFns = options.staticRenderFns;
        }
      }

      function resolveConstructorOptions(Ctor) {
        let { options } = Ctor;
        if (Ctor.super) {
          const superOptions = resolveConstructorOptions(Ctor.super);
          const cachedSuperOptions = Ctor.superOptions;
          if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            const modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
              extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
              options.components[options.name] = Ctor;
            }
          }
        }
        return options;
      }

      function resolveModifiedOptions(Ctor) {
        let modified;
        const latest = Ctor.options;
        const sealed = Ctor.sealedOptions;
        for (const key in latest) {
          if (latest[key] !== sealed[key]) {
            if (!modified) { modified = {}; }
            modified[key] = latest[key];
          }
        }
        return modified;
      }

      function Vue(options) {
        if (true
    && !(this instanceof Vue)
        ) {
          warn('Vue is a constructor and should be called with the `new` keyword');
        }
        this._init(options);
      }

      initMixin(Vue);
      stateMixin(Vue);
      eventsMixin(Vue);
      lifecycleMixin(Vue);
      renderMixin(Vue);

      /*  */

      function initUse(Vue) {
        Vue.use = function (plugin) {
          const installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
          if (installedPlugins.indexOf(plugin) > -1) {
            return this;
          }

          // additional parameters
          const args = toArray(arguments, 1);
          args.unshift(this);
          if (typeof plugin.install === 'function') {
            plugin.install.apply(plugin, args);
          } else if (typeof plugin === 'function') {
            plugin.apply(null, args);
          }
          installedPlugins.push(plugin);
          return this;
        };
      }

      /*  */

      function initMixin$1(Vue) {
        Vue.mixin = function (mixin) {
          this.options = mergeOptions(this.options, mixin);
          return this;
        };
      }

      /*  */

      function initExtend(Vue) {
        /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
        Vue.cid = 0;
        let cid = 1;

        /**
   * Class inheritance
   */
        Vue.extend = function (extendOptions) {
          extendOptions = extendOptions || {};
          const Super = this;
          const SuperId = Super.cid;
          const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
          if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
          }

          const name = extendOptions.name || Super.options.name;
          if (true && name) {
            validateComponentName(name);
          }

          const Sub = function VueComponent(options) {
            this._init(options);
          };
          Sub.prototype = Object.create(Super.prototype);
          Sub.prototype.constructor = Sub;
          Sub.cid = cid++;
          Sub.options = mergeOptions(
            Super.options,
            extendOptions,
          );
          Sub.super = Super;

          // For props and computed properties, we define the proxy getters on
          // the Vue instances at extension time, on the extended prototype. This
          // avoids Object.defineProperty calls for each instance created.
          if (Sub.options.props) {
            initProps$1(Sub);
          }
          if (Sub.options.computed) {
            initComputed$1(Sub);
          }

          // allow further extension/mixin/plugin usage
          Sub.extend = Super.extend;
          Sub.mixin = Super.mixin;
          Sub.use = Super.use;

          // create asset registers, so extended classes
          // can have their private assets too.
          ASSET_TYPES.forEach((type) => {
            Sub[type] = Super[type];
          });
          // enable recursive self-lookup
          if (name) {
            Sub.options.components[name] = Sub;
          }

          // keep a reference to the super options at extension time.
          // later at instantiation we can check if Super's options have
          // been updated.
          Sub.superOptions = Super.options;
          Sub.extendOptions = extendOptions;
          Sub.sealedOptions = extend({}, Sub.options);

          // cache constructor
          cachedCtors[SuperId] = Sub;
          return Sub;
        };
      }

      function initProps$1(Comp) {
        const { props } = Comp.options;
        for (const key in props) {
          proxy(Comp.prototype, '_props', key);
        }
      }

      function initComputed$1(Comp) {
        const { computed } = Comp.options;
        for (const key in computed) {
          defineComputed(Comp.prototype, key, computed[key]);
        }
      }

      /*  */

      function initAssetRegisters(Vue) {
        /**
   * Create asset registration methods.
   */
        ASSET_TYPES.forEach((type) => {
          Vue[type] = function (
            id,
            definition,
          ) {
            if (!definition) {
              return this.options[`${type}s`][id];
            }
            /* istanbul ignore if */
            if (true && type === 'component') {
              validateComponentName(id);
            }
            if (type === 'component' && isPlainObject(definition)) {
              definition.name = definition.name || id;
              definition = this.options._base.extend(definition);
            }
            if (type === 'directive' && typeof definition === 'function') {
              definition = { bind: definition, update: definition };
            }
            this.options[`${type}s`][id] = definition;
            return definition;
          };
        });
      }

      /*  */


      function getComponentName(opts) {
        return opts && (opts.Ctor.options.name || opts.tag);
      }

      function matches(pattern, name) {
        if (Array.isArray(pattern)) {
          return pattern.indexOf(name) > -1;
        } if (typeof pattern === 'string') {
          return pattern.split(',').indexOf(name) > -1;
        } if (isRegExp(pattern)) {
          return pattern.test(name);
        }
        /* istanbul ignore next */
        return false;
      }

      function pruneCache(keepAliveInstance, filter) {
        const { cache } = keepAliveInstance;
        const { keys } = keepAliveInstance;
        const { _vnode } = keepAliveInstance;
        for (const key in cache) {
          const cachedNode = cache[key];
          if (cachedNode) {
            const name = getComponentName(cachedNode.componentOptions);
            if (name && !filter(name)) {
              pruneCacheEntry(cache, key, keys, _vnode);
            }
          }
        }
      }

      function pruneCacheEntry(
        cache,
        key,
        keys,
        current,
      ) {
        const cached$$1 = cache[key];
        if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
          cached$$1.componentInstance.$destroy();
        }
        cache[key] = null;
        remove(keys, key);
      }

      const patternTypes = [String, RegExp, Array];

      const KeepAlive = {
        name: 'keep-alive',
        abstract: true,

        props: {
          include: patternTypes,
          exclude: patternTypes,
          max: [String, Number],
        },

        created: function created() {
          this.cache = Object.create(null);
          this.keys = [];
        },

        destroyed: function destroyed() {
          for (const key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
          }
        },

        mounted: function mounted() {
          const this$1 = this;

          this.$watch('include', (val) => {
            pruneCache(this$1, (name) => matches(val, name));
          });
          this.$watch('exclude', (val) => {
            pruneCache(this$1, (name) => !matches(val, name));
          });
        },

        render: function render() {
          const slot = this.$slots.default;
          const vnode = getFirstComponentChild(slot);
          const componentOptions = vnode && vnode.componentOptions;
          if (componentOptions) {
            // check pattern
            const name = getComponentName(componentOptions);
            const ref = this;
            const { include } = ref;
            const { exclude } = ref;
            if (
            // not included
              (include && (!name || !matches(include, name)))
        // excluded
        || (exclude && name && matches(exclude, name))
            ) {
              return vnode;
            }

            const ref$1 = this;
            const { cache } = ref$1;
            const { keys } = ref$1;
            const key = vnode.key == null
            // same constructor may get registered as different local components
            // so cid alone is not enough (#3269)
              ? componentOptions.Ctor.cid + (componentOptions.tag ? (`::${componentOptions.tag}`) : '')
              : vnode.key;
            if (cache[key]) {
              vnode.componentInstance = cache[key].componentInstance;
              // make current key freshest
              remove(keys, key);
              keys.push(key);
            } else {
              cache[key] = vnode;
              keys.push(key);
              // prune oldest entry
              if (this.max && keys.length > parseInt(this.max)) {
                pruneCacheEntry(cache, keys[0], keys, this._vnode);
              }
            }

            vnode.data.keepAlive = true;
          }
          return vnode || (slot && slot[0]);
        },
      };

      const builtInComponents = {
        KeepAlive,
      };

      /*  */

      function initGlobalAPI(Vue) {
        // config
        const configDef = {};
        configDef.get = function () { return config; };
        if (true) {
          configDef.set = function () {
            warn(
              'Do not replace the Vue.config object, set individual fields instead.',
            );
          };
        }
        Object.defineProperty(Vue, 'config', configDef);

        // exposed util methods.
        // NOTE: these are not considered part of the public API - avoid relying on
        // them unless you are aware of the risk.
        Vue.util = {
          warn,
          extend,
          mergeOptions,
          defineReactive: defineReactive$$1,
        };

        Vue.set = set;
        Vue.delete = del;
        Vue.nextTick = nextTick;

        // 2.6 explicit observable API
        Vue.observable = function (obj) {
          observe(obj);
          return obj;
        };

        Vue.options = Object.create(null);
        ASSET_TYPES.forEach((type) => {
          Vue.options[`${type}s`] = Object.create(null);
        });

        // this is used to identify the "base" constructor to extend all plain-object
        // components with in Weex's multi-instance scenarios.
        Vue.options._base = Vue;

        extend(Vue.options.components, builtInComponents);

        initUse(Vue);
        initMixin$1(Vue);
        initExtend(Vue);
        initAssetRegisters(Vue);
      }

      initGlobalAPI(Vue);

      Object.defineProperty(Vue.prototype, '$isServer', {
        get: isServerRendering,
      });

      Object.defineProperty(Vue.prototype, '$ssrContext', {
        get: function get() {
          /* istanbul ignore next */
          return this.$vnode && this.$vnode.ssrContext;
        },
      });

      // expose FunctionalRenderContext for ssr runtime helper installation
      Object.defineProperty(Vue, 'FunctionalRenderContext', {
        value: FunctionalRenderContext,
      });

      Vue.version = '2.6.10';

      /**
 * https://raw.githubusercontent.com/Tencent/westore/master/packages/westore/utils/diff.js
 */
      const ARRAYTYPE = '[object Array]';
      const OBJECTTYPE = '[object Object]';
      // const FUNCTIONTYPE = '[object Function]'

      function diff(current, pre) {
        const result = {};
        syncKeys(current, pre);
        _diff(current, pre, '', result);
        return result;
      }

      function syncKeys(current, pre) {
        if (current === pre) { return; }
        const rootCurrentType = type(current);
        const rootPreType = type(pre);
        if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
          if (Object.keys(current).length >= Object.keys(pre).length) {
            for (const key in pre) {
              const currentValue = current[key];
              if (currentValue === undefined) {
                current[key] = null;
              } else {
                syncKeys(currentValue, pre[key]);
              }
            }
          }
        } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
          if (current.length >= pre.length) {
            pre.forEach((item, index) => {
              syncKeys(current[index], item);
            });
          }
        }
      }

      function _diff(current, pre, path, result) {
        if (current === pre) { return; }
        const rootCurrentType = type(current);
        const rootPreType = type(pre);
        if (rootCurrentType == OBJECTTYPE) {
          if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
            setResult(result, path, current);
          } else {
            const loop = function (key) {
              const currentValue = current[key];
              const preValue = pre[key];
              const currentType = type(currentValue);
              const preType = type(preValue);
              if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
                if (currentValue != pre[key]) {
                  setResult(result, (path == '' ? '' : `${path}.`) + key, currentValue);
                }
              } else if (currentType == ARRAYTYPE) {
                if (preType != ARRAYTYPE) {
                  setResult(result, (path == '' ? '' : `${path}.`) + key, currentValue);
                } else if (currentValue.length < preValue.length) {
                  setResult(result, (path == '' ? '' : `${path}.`) + key, currentValue);
                } else {
                  currentValue.forEach((item, index) => {
                    _diff(item, preValue[index], `${(path == '' ? '' : `${path}.`) + key}[${index}]`, result);
                  });
                }
              } else if (currentType == OBJECTTYPE) {
                if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
                  setResult(result, (path == '' ? '' : `${path}.`) + key, currentValue);
                } else {
                  for (const subKey in currentValue) {
                    _diff(currentValue[subKey], preValue[subKey], `${(path == '' ? '' : `${path}.`) + key}.${subKey}`, result);
                  }
                }
              }
            };

            for (const key in current) loop(key);
          }
        } else if (rootCurrentType == ARRAYTYPE) {
          if (rootPreType != ARRAYTYPE) {
            setResult(result, path, current);
          } else if (current.length < pre.length) {
            setResult(result, path, current);
          } else {
            current.forEach((item, index) => {
              _diff(item, pre[index], `${path}[${index}]`, result);
            });
          }
        } else {
          setResult(result, path, current);
        }
      }

      function setResult(result, k, v) {
        // if (type(v) != FUNCTIONTYPE) {
        result[k] = v;
        // }
      }

      function type(obj) {
        return Object.prototype.toString.call(obj);
      }

      /*  */

      function flushCallbacks$1(vm) {
        if (vm.__next_tick_callbacks && vm.__next_tick_callbacks.length) {
          if (Object({ NODE_ENV: 'development', VUE_APP_PLATFORM: 'mp-weixin', BASE_URL: '/' }).VUE_APP_DEBUG) {
            const mpInstance = vm.$scope;
            console.log(`[${+new Date()}][${mpInstance.is || mpInstance.route}][${vm._uid
            }]:flushCallbacks[${vm.__next_tick_callbacks.length}]`);
          }
          const copies = vm.__next_tick_callbacks.slice(0);
          vm.__next_tick_callbacks.length = 0;
          for (let i = 0; i < copies.length; i++) {
            copies[i]();
          }
        }
      }

      function hasRenderWatcher(vm) {
        return queue.find((watcher) => vm._watcher === watcher);
      }

      function nextTick$1(vm, cb) {
        // 1.nextTick 之前 已 setData 且 setData 还未回调完成
        // 2.nextTick 之前存在 render watcher
        if (!vm.__next_tick_pending && !hasRenderWatcher(vm)) {
          if (Object({ NODE_ENV: 'development', VUE_APP_PLATFORM: 'mp-weixin', BASE_URL: '/' }).VUE_APP_DEBUG) {
            const mpInstance = vm.$scope;
            console.log(`[${+new Date()}][${mpInstance.is || mpInstance.route}][${vm._uid
            }]:nextVueTick`);
          }
          return nextTick(cb, vm);
        }
        if (Object({ NODE_ENV: 'development', VUE_APP_PLATFORM: 'mp-weixin', BASE_URL: '/' }).VUE_APP_DEBUG) {
          const mpInstance$1 = vm.$scope;
          console.log(`[${+new Date()}][${mpInstance$1.is || mpInstance$1.route}][${vm._uid
          }]:nextMPTick`);
        }

        let _resolve;
        if (!vm.__next_tick_callbacks) {
          vm.__next_tick_callbacks = [];
        }
        vm.__next_tick_callbacks.push(() => {
          if (cb) {
            try {
              cb.call(vm);
            } catch (e) {
              handleError(e, vm, 'nextTick');
            }
          } else if (_resolve) {
            _resolve(vm);
          }
        });
        // $flow-disable-line
        if (!cb && typeof Promise !== 'undefined') {
          return new Promise(((resolve) => {
            _resolve = resolve;
          }));
        }
      }

      /*  */

      function cloneWithData(vm) {
        // 确保当前 vm 所有数据被同步
        const dataKeys = [].concat(
          Object.keys(vm._data || {}),
          Object.keys(vm._computedWatchers || {}),
        );

        const ret = dataKeys.reduce((ret, key) => {
          ret[key] = vm[key];
          return ret;
        }, Object.create(null));
        // TODO 需要把无用数据处理掉，比如 list=>l0 则 list 需要移除，否则多传输一份数据
        Object.assign(ret, vm.$mp.data || {});
        if (
          Array.isArray(vm.$options.behaviors)
        && vm.$options.behaviors.indexOf('uni://form-field') !== -1
        ) { // form-field
          ret.name = vm.name;
          ret.value = vm.value;
        }
        return JSON.parse(JSON.stringify(ret));
      }

      const patch = function (oldVnode, vnode) {
        const this$1 = this;

        if (vnode === null) { // destroy
          return;
        }
        if (this.mpType === 'page' || this.mpType === 'component') {
          const mpInstance = this.$scope;
          const data = cloneWithData(this);
          data.__webviewId__ = mpInstance.data.__webviewId__;
          const mpData = Object.create(null);
          Object.keys(data).forEach((key) => { // 仅同步 data 中有的数据
            mpData[key] = mpInstance.data[key];
          });
          const diffData = diff(data, mpData);
          if (Object.keys(diffData).length) {
            if (Object({ NODE_ENV: 'development', VUE_APP_PLATFORM: 'mp-weixin', BASE_URL: '/' }).VUE_APP_DEBUG) {
              console.log(`[${+new Date()}][${mpInstance.is || mpInstance.route}][${this._uid
              }]差量更新`,
              JSON.stringify(diffData));
            }
            this.__next_tick_pending = true;
            mpInstance.setData(diffData, () => {
              this$1.__next_tick_pending = false;
              flushCallbacks$1(this$1);
            });
          } else {
            flushCallbacks$1(this);
          }
        }
      };

      /*  */

      function createEmptyRender() {

      }

      function mountComponent$1(
        vm,
        el,
        hydrating,
      ) {
        if (!vm.mpType) { // main.js 中的 new Vue
          return vm;
        }
        if (vm.mpType === 'app') {
          vm.$options.render = createEmptyRender;
        }
        if (!vm.$options.render) {
          vm.$options.render = createEmptyRender;
          if (true) {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#')
        || vm.$options.el || el) {
              warn(
                'You are using the runtime-only build of Vue where the template '
          + 'compiler is not available. Either pre-compile the templates into '
          + 'render functions, or use the compiler-included build.',
                vm,
              );
            } else {
              warn(
                'Failed to mount component: template or render function not defined.',
                vm,
              );
            }
          }
        }

        vm.mpHost !== 'mp-toutiao' && callHook(vm, 'beforeMount');

        const updateComponent = function () {
          vm._update(vm._render(), hydrating);
        };

        // we set this to vm._watcher inside the watcher's constructor
        // since the watcher's initial patch may call $forceUpdate (e.g. inside child
        // component's mounted hook), which relies on vm._watcher being already defined
        new Watcher(vm, updateComponent, noop, {
          before: function before() {
            if (vm._isMounted && !vm._isDestroyed) {
              callHook(vm, 'beforeUpdate');
            }
          },
        }, true /* isRenderWatcher */);
        hydrating = false;
        return vm;
      }

      /*  */

      function renderClass(
        staticClass,
        dynamicClass,
      ) {
        if (isDef(staticClass) || isDef(dynamicClass)) {
          return concat(staticClass, stringifyClass(dynamicClass));
        }
        /* istanbul ignore next */
        return '';
      }

      function concat(a, b) {
        return a ? b ? (`${a} ${b}`) : a : (b || '');
      }

      function stringifyClass(value) {
        if (Array.isArray(value)) {
          return stringifyArray(value);
        }
        if (isObject(value)) {
          return stringifyObject(value);
        }
        if (typeof value === 'string') {
          return value;
        }
        /* istanbul ignore next */
        return '';
      }

      function stringifyArray(value) {
        let res = '';
        let stringified;
        for (let i = 0, l = value.length; i < l; i++) {
          if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
            if (res) { res += ' '; }
            res += stringified;
          }
        }
        return res;
      }

      function stringifyObject(value) {
        let res = '';
        for (const key in value) {
          if (value[key]) {
            if (res) { res += ' '; }
            res += key;
          }
        }
        return res;
      }

      /*  */

      const parseStyleText = cached((cssText) => {
        const res = {};
        const listDelimiter = /;(?![^(]*\))/g;
        const propertyDelimiter = /:(.+)/;
        cssText.split(listDelimiter).forEach((item) => {
          if (item) {
            const tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
          }
        });
        return res;
      });

      // normalize possible array / string values into Object
      function normalizeStyleBinding(bindingStyle) {
        if (Array.isArray(bindingStyle)) {
          return toObject(bindingStyle);
        }
        if (typeof bindingStyle === 'string') {
          return parseStyleText(bindingStyle);
        }
        return bindingStyle;
      }

      /*  */

      const MP_METHODS = ['createSelectorQuery', 'createIntersectionObserver', 'selectAllComponents', 'selectComponent'];

      function getTarget(obj, path) {
        const parts = path.split('.');
        let key = parts[0];
        if (key.indexOf('__$n') === 0) { // number index
          key = parseInt(key.replace('__$n', ''));
        }
        if (parts.length === 1) {
          return obj[key];
        }
        return getTarget(obj[key], parts.slice(1).join('.'));
      }

      function internalMixin(Vue) {
        const oldEmit = Vue.prototype.$emit;

        Vue.prototype.$emit = function (event) {
          if (this.$scope && event) {
            this.$scope.triggerEvent(event, {
              __args__: toArray(arguments, 1),
            });
          }
          return oldEmit.apply(this, arguments);
        };

        Vue.prototype.$nextTick = function (fn) {
          return nextTick$1(this, fn);
        };

        MP_METHODS.forEach((method) => {
          Vue.prototype[method] = function (args) {
            if (this.$scope) {
              return this.$scope[method](args);
            }
          };
        });

        Vue.prototype.__init_provide = initProvide;

        Vue.prototype.__init_injections = initInjections;

        Vue.prototype.__call_hook = function (hook, args) {
          const vm = this;
          // #7573 disable dep collection when invoking lifecycle hooks
          pushTarget();
          const handlers = vm.$options[hook];
          const info = `${hook} hook`;
          let ret;
          if (handlers) {
            for (let i = 0, j = handlers.length; i < j; i++) {
              ret = invokeWithErrorHandling(handlers[i], vm, args ? [args] : null, vm, info);
            }
          }
          if (vm._hasHookEvent) {
            vm.$emit(`hook:${hook}`);
          }
          popTarget();
          return ret;
        };

        Vue.prototype.__set_model = function (target, key, value, modifiers) {
          if (Array.isArray(modifiers)) {
            if (modifiers.indexOf('trim') !== -1) {
              value = value.trim();
            }
            if (modifiers.indexOf('number') !== -1) {
              value = this._n(value);
            }
          }
          if (!target) {
            target = this;
          }
          target[key] = value;
        };

        Vue.prototype.__set_sync = function (target, key, value) {
          if (!target) {
            target = this;
          }
          target[key] = value;
        };

        Vue.prototype.__get_orig = function (item) {
          if (isPlainObject(item)) {
            return item.$orig || item;
          }
          return item;
        };

        Vue.prototype.__get_value = function (dataPath, target) {
          return getTarget(target || this, dataPath);
        };


        Vue.prototype.__get_class = function (dynamicClass, staticClass) {
          return renderClass(staticClass, dynamicClass);
        };

        Vue.prototype.__get_style = function (dynamicStyle, staticStyle) {
          if (!dynamicStyle && !staticStyle) {
            return '';
          }
          const dynamicStyleObj = normalizeStyleBinding(dynamicStyle);
          const styleObj = staticStyle ? extend(staticStyle, dynamicStyleObj) : dynamicStyleObj;
          return Object.keys(styleObj).map((name) => (`${hyphenate(name)}:${styleObj[name]}`)).join(';');
        };
      }

      /*  */

      const LIFECYCLE_HOOKS$1 = [
        // App
        'onLaunch',
        'onShow',
        'onHide',
        'onUniNViewMessage',
        'onError',
        // Page
        'onLoad',
        // 'onShow',
        'onReady',
        // 'onHide',
        'onUnload',
        'onPullDownRefresh',
        'onReachBottom',
        'onTabItemTap',
        'onShareAppMessage',
        'onResize',
        'onPageScroll',
        'onNavigationBarButtonTap',
        'onBackPress',
        'onNavigationBarSearchInputChanged',
        'onNavigationBarSearchInputConfirmed',
        'onNavigationBarSearchInputClicked',
        // Component
        // 'onReady', // 兼容旧版本，应该移除该事件
        'onPageShow',
        'onPageHide',
        'onPageResize',
      ];
      function lifecycleMixin$1(Vue) {
        // fixed vue-class-component
        const oldExtend = Vue.extend;
        Vue.extend = function (extendOptions) {
          extendOptions = extendOptions || {};

          const { methods } = extendOptions;
          if (methods) {
            Object.keys(methods).forEach((methodName) => {
              if (LIFECYCLE_HOOKS$1.indexOf(methodName) !== -1) {
                extendOptions[methodName] = methods[methodName];
                delete methods[methodName];
              }
            });
          }

          return oldExtend.call(this, extendOptions);
        };

        const strategies = Vue.config.optionMergeStrategies;
        const mergeHook = strategies.created;
        LIFECYCLE_HOOKS$1.forEach((hook) => {
          strategies[hook] = mergeHook;
        });

        Vue.prototype.__lifecycle_hooks__ = LIFECYCLE_HOOKS$1;
      }

      /*  */

      // install platform patch function
      Vue.prototype.__patch__ = patch;

      // public mount method
      Vue.prototype.$mount = function (
        el,
        hydrating,
      ) {
        return mountComponent$1(this, el, hydrating);
      };

      lifecycleMixin$1(Vue);
      internalMixin(Vue);

      /*  */

      /* harmony default export */ __webpack_exports__.default = (Vue);
      /* WEBPACK VAR INJECTION */ }.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ './node_modules/webpack/buildin/global.js')));
    /** */ }),

  /** */ './node_modules/regenerator-runtime/runtime-module.js':
  /*! ************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \*********************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports, __webpack_require__) {
    /**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

    // This method of obtaining a reference to the global object needs to be
    // kept identical to the way it is obtained in runtime.js
    const g = (function () {
      return this || (typeof self === 'object' && self);
    }()) || Function('return this')();

    // Use `getOwnPropertyNames` because not all browsers support calling
    // `hasOwnProperty` on the global `self` object in a worker. See #183.
    const hadRuntime = g.regeneratorRuntime
  && Object.getOwnPropertyNames(g).indexOf('regeneratorRuntime') >= 0;

    // Save the old regeneratorRuntime in case it needs to be restored later.
    const oldRuntime = hadRuntime && g.regeneratorRuntime;

    // Force reevalutation of runtime.js.
    g.regeneratorRuntime = undefined;

    module.exports = __webpack_require__(/*! ./runtime */ './node_modules/regenerator-runtime/runtime.js');

    if (hadRuntime) {
      // Restore the original runtime.
      g.regeneratorRuntime = oldRuntime;
    } else {
      // Remove the global property added by runtime.js.
      try {
        delete g.regeneratorRuntime;
      } catch (e) {
        g.regeneratorRuntime = undefined;
      }
    }
    /** */ }),

  /** */ './node_modules/regenerator-runtime/runtime.js':
  /*! *****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \**************************************************** */
  /*! no static exports found */
  /** */ (function (module, exports) {
    /**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

    !(function (global) {
      const Op = Object.prototype;
      const hasOwn = Op.hasOwnProperty;
      let undefined; // More compressible than void 0.
      const $Symbol = typeof Symbol === 'function' ? Symbol : {};
      const iteratorSymbol = $Symbol.iterator || '@@iterator';
      const asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator';
      const toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag';

      const inModule = typeof module === 'object';
      let runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          // If regeneratorRuntime is defined globally and we're in a module,
          // make the exports object identical to regeneratorRuntime.
          module.exports = runtime;
        }
        // Don't bother evaluating the rest of this file if the runtime was
        // already defined globally.
        return;
      }

      // Define the runtime globally (as expected by generated code) as either
      // module.exports (if we're in a module) or a new, empty object.
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        const protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        const generator = Object.create(protoGenerator.prototype);
        const context = new Context(tryLocsList || []);

        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        generator._invoke = makeInvokeMethod(innerFn, self, context);

        return generator;
      }
      runtime.wrap = wrap;

      // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.
      function tryCatch(fn, obj, arg) {
        try {
          return { type: 'normal', arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: 'throw', arg: err };
        }
      }

      const GenStateSuspendedStart = 'suspendedStart';
      const GenStateSuspendedYield = 'suspendedYield';
      const GenStateExecuting = 'executing';
      const GenStateCompleted = 'completed';

      // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.
      const ContinueSentinel = {};

      // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}

      // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.
      let IteratorPrototype = {};
      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      const getProto = Object.getPrototypeOf;
      const NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype
      && NativeIteratorPrototype !== Op
      && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      const Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = 'GeneratorFunction';

      // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.
      function defineIteratorMethods(prototype) {
        ['next', 'throw', 'return'].forEach((method) => {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      runtime.isGeneratorFunction = function (genFun) {
        const ctor = typeof genFun === 'function' && genFun.constructor;
        return ctor
          ? ctor === GeneratorFunction
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        || (ctor.displayName || ctor.name) === 'GeneratorFunction'
          : false;
      };

      runtime.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = 'GeneratorFunction';
          }
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.
      runtime.awrap = function (arg) {
        return { __await: arg };
      };

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          const record = tryCatch(generator[method], generator, arg);
          if (record.type === 'throw') {
            reject(record.arg);
          } else {
            const result = record.arg;
            const { value } = result;
            if (value
            && typeof value === 'object'
            && hasOwn.call(value, '__await')) {
              return Promise.resolve(value.__await).then((value) => {
                invoke('next', value, resolve, reject);
              }, (err) => {
                invoke('throw', err, resolve, reject);
              });
            }

            return Promise.resolve(value).then((unwrapped) => {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, (error) =>
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
              invoke('throw', error, resolve, reject));
          }
        }

        let previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(((resolve, reject) => {
              invoke(method, arg, resolve, reject);
            }));
          }

          return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg,
        ) : callInvokeWithMethodAndArg();
        }

        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);
      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };
      runtime.AsyncIterator = AsyncIterator;

      // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.
      runtime.async = function (innerFn, outerFn, self, tryLocsList) {
        const iter = new AsyncIterator(
          wrap(innerFn, outerFn, self, tryLocsList),
        );

        return runtime.isGeneratorFunction(outerFn)
          ? iter // If outerFn is a generator, return the full iterator.
          : iter.next().then((result) => (result.done ? result.value : iter.next()));
      };

      function makeInvokeMethod(innerFn, self, context) {
        let state = GenStateSuspendedStart;

        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error('Generator is already running');
          }

          if (state === GenStateCompleted) {
            if (method === 'throw') {
              throw arg;
            }

            // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            const { delegate } = context;
            if (delegate) {
              const delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === 'next') {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === 'throw') {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === 'return') {
              context.abrupt('return', context.arg);
            }

            state = GenStateExecuting;

            const record = tryCatch(innerFn, self, context);
            if (record.type === 'normal') {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done
                ? GenStateCompleted
                : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done,
              };
            } if (record.type === 'throw') {
              state = GenStateCompleted;
              // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.
              context.method = 'throw';
              context.arg = record.arg;
            }
          }
        };
      }

      // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.
      function maybeInvokeDelegate(delegate, context) {
        const method = delegate.iterator[context.method];
        if (method === undefined) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === 'throw') {
            if (delegate.iterator.return) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = 'return';
              context.arg = undefined;
              maybeInvokeDelegate(delegate, context);

              if (context.method === 'throw') {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = 'throw';
            context.arg = new TypeError(
              "The iterator does not provide a 'throw' method",
            );
          }

          return ContinueSentinel;
        }

        const record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === 'throw') {
          context.method = 'throw';
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        const info = record.arg;

        if (!info) {
          context.method = 'throw';
          context.arg = new TypeError('iterator result is not an object');
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value;

          // Resume execution at the desired location (see delegateYield).
          context.next = delegate.nextLoc;

          // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.
          if (context.method !== 'return') {
            context.method = 'next';
            context.arg = undefined;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        }

        // The delegate iterator is finished, so forget it and continue with
        // the outer generator.
        context.delegate = null;
        return ContinueSentinel;
      }

      // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.
      defineIteratorMethods(Gp);

      Gp[toStringTagSymbol] = 'Generator';

      // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.
      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return '[object Generator]';
      };

      function pushTryEntry(locs) {
        const entry = { tryLoc: locs[0] };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        const record = entry.completion || {};
        record.type = 'normal';
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{ tryLoc: 'root' }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      runtime.keys = function (object) {
        const keys = [];
        for (const key in object) {
          keys.push(key);
        }
        keys.reverse();

        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
          while (keys.length) {
            const key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.
          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          const iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === 'function') {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            let i = -1; const
              next = function next() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next.value = iterable[i];
                    next.done = false;
                    return next;
                  }
                }

                next.value = undefined;
                next.done = true;

                return next;
              };

            return next.next = next;
          }
        }

        // Return an iterator with no values.
        return { next: doneResult };
      }
      runtime.values = values;

      function doneResult() {
        return { value: undefined, done: true };
      }

      Context.prototype = {
        constructor: Context,

        reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.
          this.sent = this._sent = undefined;
          this.done = false;
          this.delegate = null;

          this.method = 'next';
          this.arg = undefined;

          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (const name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === 't'
              && hasOwn.call(this, name)
              && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },

        stop() {
          this.done = true;

          const rootEntry = this.tryEntries[0];
          const rootRecord = rootEntry.completion;
          if (rootRecord.type === 'throw') {
            throw rootRecord.arg;
          }

          return this.rval;
        },

        dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          const context = this;
          function handle(loc, caught) {
            record.type = 'throw';
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = 'next';
              context.arg = undefined;
            }

            return !!caught;
          }

          for (let i = this.tryEntries.length - 1; i >= 0; --i) {
            const entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === 'root') {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle('end');
            }

            if (entry.tryLoc <= this.prev) {
              const hasCatch = hasOwn.call(entry, 'catchLoc');
              const hasFinally = hasOwn.call(entry, 'finallyLoc');

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error('try statement without catch or finally');
              }
            }
          }
        },

        abrupt(type, arg) {
          for (let i = this.tryEntries.length - 1; i >= 0; --i) {
            const entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev
            && hasOwn.call(entry, 'finallyLoc')
            && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry
          && (type === 'break'
           || type === 'continue')
          && finallyEntry.tryLoc <= arg
          && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          const record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = 'next';
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },

        complete(record, afterLoc) {
          if (record.type === 'throw') {
            throw record.arg;
          }

          if (record.type === 'break'
          || record.type === 'continue') {
            this.next = record.arg;
          } else if (record.type === 'return') {
            this.rval = this.arg = record.arg;
            this.method = 'return';
            this.next = 'end';
          } else if (record.type === 'normal' && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },

        finish(finallyLoc) {
          for (let i = this.tryEntries.length - 1; i >= 0; --i) {
            const entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },

        catch(tryLoc) {
          for (let i = this.tryEntries.length - 1; i >= 0; --i) {
            const entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              const record = entry.completion;
              if (record.type === 'throw') {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }

          // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.
          throw new Error('illegal catch attempt');
        },

        delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc,
          };

          if (this.method === 'next') {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined;
          }

          return ContinueSentinel;
        },
      };
    }(
      // In sloppy mode, unbound `this` refers to the global object, fallback to
      // Function constructor if we're in global strict mode. That is sadly a form
      // of indirect eval which violates Content Security Policy.
      (function () {
        return this || (typeof self === 'object' && self);
      }()) || Function('return this')(),
    ));
    /** */ }),

  /** */ './node_modules/vue-loader/lib/runtime/componentNormalizer.js':
  /*! ********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \******************************************************************* */
  /*! exports provided: default */
  /** */ (function (module, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'default', () => normalizeComponent);
    /* globals __VUE_SSR_CONTEXT__ */

    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.

    function normalizeComponent(
      scriptExports,
      render,
      staticRenderFns,
      functionalTemplate,
      injectStyles,
      scopeId,
      moduleIdentifier, /* server only */
      shadowMode, /* vue-cli only */
    ) {
      // Vue.extend constructor export interop
      const options = typeof scriptExports === 'function'
        ? scriptExports.options
        : scriptExports;

      // render functions
      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      }

      // functional template
      if (functionalTemplate) {
        options.functional = true;
      }

      // scopedId
      if (scopeId) {
        options._scopeId = `data-v-${scopeId}`;
      }

      let hook;
      if (moduleIdentifier) { // server build
        hook = function (context) {
          // 2.3 injection
          context = context // cached call
        || (this.$vnode && this.$vnode.ssrContext) // stateful
        || (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
          // 2.2 with runInNewContext: true
          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          }
          // inject component styles
          if (injectStyles) {
            injectStyles.call(this, context);
          }
          // register component module identifier for async chunk inferrence
          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode
          ? function () { injectStyles.call(this, this.$root.$options.shadowRoot); }
          : injectStyles;
      }

      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook;
          // register for functioal component in vue file
          const originalRender = options.render;
          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          const existing = options.beforeCreate;
          options.beforeCreate = existing
            ? [].concat(existing, hook)
            : [hook];
        }
      }

      return {
        exports: scriptExports,
        options,
      };
    }
    /** */ }),

  /** */ './node_modules/vuex/dist/vuex.esm.js':
  /*! ********************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm.js ***!
  \******************************************* */
  /*! exports provided: Store, install, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers, default */
  /** */ (function (module, __webpack_exports__, __webpack_require__) {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'Store', () => Store);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'install', () => install);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'mapState', () => mapState);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'mapMutations', () => mapMutations);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'mapGetters', () => mapGetters);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'mapActions', () => mapActions);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, 'createNamespacedHelpers', () => createNamespacedHelpers);
    /**
 * vuex v3.0.1
 * (c) 2017 Evan You
 * @license MIT
 */
    const applyMixin = function (Vue) {
      const version = Number(Vue.version.split('.')[0]);

      if (version >= 2) {
        Vue.mixin({ beforeCreate: vuexInit });
      } else {
        // override init and inject vuex init procedure
        // for 1.x backwards compatibility.
        const { _init } = Vue.prototype;
        Vue.prototype._init = function (options) {
          if (options === void 0) options = {};

          options.init = options.init
            ? [vuexInit].concat(options.init)
            : vuexInit;
          _init.call(this, options);
        };
      }

      /**
   * Vuex init hook, injected into each instances init hooks list.
   */

      function vuexInit() {
        const options = this.$options;
        // store injection
        if (options.store) {
          this.$store = typeof options.store === 'function'
            ? options.store()
            : options.store;
        } else if (options.parent && options.parent.$store) {
          this.$store = options.parent.$store;
        }
      }
    };

    const devtoolHook = typeof window !== 'undefined'
  && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

    function devtoolPlugin(store) {
      if (!devtoolHook) { return; }

      store._devtoolHook = devtoolHook;

      devtoolHook.emit('vuex:init', store);

      devtoolHook.on('vuex:travel-to-state', (targetState) => {
        store.replaceState(targetState);
      });

      store.subscribe((mutation, state) => {
        devtoolHook.emit('vuex:mutation', mutation, state);
      });
    }

    /**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
    /**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


    /**
 * forEach for object
 */
    function forEachValue(obj, fn) {
      Object.keys(obj).forEach((key) => fn(obj[key], key));
    }

    function isObject(obj) {
      return obj !== null && typeof obj === 'object';
    }

    function isPromise(val) {
      return val && typeof val.then === 'function';
    }

    function assert(condition, msg) {
      if (!condition) { throw new Error((`[vuex] ${msg}`)); }
    }

    const Module = function Module(rawModule, runtime) {
      this.runtime = runtime;
      this._children = Object.create(null);
      this._rawModule = rawModule;
      const rawState = rawModule.state;
      this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
    };

    const prototypeAccessors$1 = { namespaced: { configurable: true } };

    prototypeAccessors$1.namespaced.get = function () {
      return !!this._rawModule.namespaced;
    };

    Module.prototype.addChild = function addChild(key, module) {
      this._children[key] = module;
    };

    Module.prototype.removeChild = function removeChild(key) {
      delete this._children[key];
    };

    Module.prototype.getChild = function getChild(key) {
      return this._children[key];
    };

    Module.prototype.update = function update(rawModule) {
      this._rawModule.namespaced = rawModule.namespaced;
      if (rawModule.actions) {
        this._rawModule.actions = rawModule.actions;
      }
      if (rawModule.mutations) {
        this._rawModule.mutations = rawModule.mutations;
      }
      if (rawModule.getters) {
        this._rawModule.getters = rawModule.getters;
      }
    };

    Module.prototype.forEachChild = function forEachChild(fn) {
      forEachValue(this._children, fn);
    };

    Module.prototype.forEachGetter = function forEachGetter(fn) {
      if (this._rawModule.getters) {
        forEachValue(this._rawModule.getters, fn);
      }
    };

    Module.prototype.forEachAction = function forEachAction(fn) {
      if (this._rawModule.actions) {
        forEachValue(this._rawModule.actions, fn);
      }
    };

    Module.prototype.forEachMutation = function forEachMutation(fn) {
      if (this._rawModule.mutations) {
        forEachValue(this._rawModule.mutations, fn);
      }
    };

    Object.defineProperties(Module.prototype, prototypeAccessors$1);

    const ModuleCollection = function ModuleCollection(rawRootModule) {
      // register root module (Vuex.Store options)
      this.register([], rawRootModule, false);
    };

    ModuleCollection.prototype.get = function get(path) {
      return path.reduce((module, key) => module.getChild(key), this.root);
    };

    ModuleCollection.prototype.getNamespace = function getNamespace(path) {
      let module = this.root;
      return path.reduce((namespace, key) => {
        module = module.getChild(key);
        return namespace + (module.namespaced ? `${key}/` : '');
      }, '');
    };

    ModuleCollection.prototype.update = function update$1(rawRootModule) {
      update([], this.root, rawRootModule);
    };

    ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
      const this$1 = this;
      if (runtime === void 0) runtime = true;

      if (true) {
        assertRawModule(path, rawModule);
      }

      const newModule = new Module(rawModule, runtime);
      if (path.length === 0) {
        this.root = newModule;
      } else {
        const parent = this.get(path.slice(0, -1));
        parent.addChild(path[path.length - 1], newModule);
      }

      // register nested modules
      if (rawModule.modules) {
        forEachValue(rawModule.modules, (rawChildModule, key) => {
          this$1.register(path.concat(key), rawChildModule, runtime);
        });
      }
    };

    ModuleCollection.prototype.unregister = function unregister(path) {
      const parent = this.get(path.slice(0, -1));
      const key = path[path.length - 1];
      if (!parent.getChild(key).runtime) { return; }

      parent.removeChild(key);
    };

    function update(path, targetModule, newModule) {
      if (true) {
        assertRawModule(path, newModule);
      }

      // update target module
      targetModule.update(newModule);

      // update nested modules
      if (newModule.modules) {
        for (const key in newModule.modules) {
          if (!targetModule.getChild(key)) {
            if (true) {
              console.warn(
                `[vuex] trying to add a new module '${key}' on hot reloading, `
            + 'manual reload is needed',
              );
            }
            return;
          }
          update(
            path.concat(key),
            targetModule.getChild(key),
            newModule.modules[key],
          );
        }
      }
    }

    const functionAssert = {
      assert(value) { return typeof value === 'function'; },
      expected: 'function',
    };

    const objectAssert = {
      assert(value) {
        return typeof value === 'function'
    || (typeof value === 'object' && typeof value.handler === 'function');
      },
      expected: 'function or object with "handler" function',
    };

    const assertTypes = {
      getters: functionAssert,
      mutations: functionAssert,
      actions: objectAssert,
    };

    function assertRawModule(path, rawModule) {
      Object.keys(assertTypes).forEach((key) => {
        if (!rawModule[key]) { return; }

        const assertOptions = assertTypes[key];

        forEachValue(rawModule[key], (value, type) => {
          assert(
            assertOptions.assert(value),
            makeAssertionMessage(path, key, type, value, assertOptions.expected),
          );
        });
      });
    }

    function makeAssertionMessage(path, key, type, value, expected) {
      let buf = `${key} should be ${expected} but "${key}.${type}"`;
      if (path.length > 0) {
        buf += ` in module "${path.join('.')}"`;
      }
      buf += ` is ${JSON.stringify(value)}.`;
      return buf;
    }

    let Vue; // bind on install

    var Store = function Store(options) {
      const this$1 = this;
      if (options === void 0) options = {};

      // Auto install if it is not done yet and `window` has `Vue`.
      // To allow users to avoid auto-installation in some cases,
      // this code should be placed here. See #731
      if (!Vue && typeof window !== 'undefined' && window.Vue) {
        install(window.Vue);
      }

      if (true) {
        assert(Vue, 'must call Vue.use(Vuex) before creating a store instance.');
        assert(typeof Promise !== 'undefined', 'vuex requires a Promise polyfill in this browser.');
        assert(this instanceof Store, 'Store must be called with the new operator.');
      }

      let { plugins } = options; if (plugins === void 0) plugins = [];
      let { strict } = options; if (strict === void 0) strict = false;

      let { state } = options; if (state === void 0) state = {};
      if (typeof state === 'function') {
        state = state() || {};
      }

      // store internal state
      this._committing = false;
      this._actions = Object.create(null);
      this._actionSubscribers = [];
      this._mutations = Object.create(null);
      this._wrappedGetters = Object.create(null);
      this._modules = new ModuleCollection(options);
      this._modulesNamespaceMap = Object.create(null);
      this._subscribers = [];
      this._watcherVM = new Vue();

      // bind commit and dispatch to self
      const store = this;
      const ref = this;
      const { dispatch } = ref;
      const { commit } = ref;
      this.dispatch = function boundDispatch(type, payload) {
        return dispatch.call(store, type, payload);
      };
      this.commit = function boundCommit(type, payload, options) {
        return commit.call(store, type, payload, options);
      };

      // strict mode
      this.strict = strict;

      // init root module.
      // this also recursively registers all sub-modules
      // and collects all module getters inside this._wrappedGetters
      installModule(this, state, [], this._modules.root);

      // initialize the store vm, which is responsible for the reactivity
      // (also registers _wrappedGetters as computed properties)
      resetStoreVM(this, state);

      // apply plugins
      plugins.forEach((plugin) => plugin(this$1));

      if (Vue.config.devtools) {
        devtoolPlugin(this);
      }
    };

    const prototypeAccessors = { state: { configurable: true } };

    prototypeAccessors.state.get = function () {
      return this._vm._data.$$state;
    };

    prototypeAccessors.state.set = function (v) {
      if (true) {
        assert(false, 'Use store.replaceState() to explicit replace store state.');
      }
    };

    Store.prototype.commit = function commit(_type, _payload, _options) {
      const this$1 = this;

      // check object-style commit
      const ref = unifyObjectStyle(_type, _payload, _options);
      const { type } = ref;
      const { payload } = ref;
      const { options } = ref;

      const mutation = { type, payload };
      const entry = this._mutations[type];
      if (!entry) {
        if (true) {
          console.error((`[vuex] unknown mutation type: ${type}`));
        }
        return;
      }
      this._withCommit(() => {
        entry.forEach((handler) => {
          handler(payload);
        });
      });
      this._subscribers.forEach((sub) => sub(mutation, this$1.state));

      if (
        true
    && options && options.silent
      ) {
        console.warn(
          `[vuex] mutation type: ${type}. Silent option has been removed. `
      + 'Use the filter functionality in the vue-devtools',
        );
      }
    };

    Store.prototype.dispatch = function dispatch(_type, _payload) {
      const this$1 = this;

      // check object-style dispatch
      const ref = unifyObjectStyle(_type, _payload);
      const { type } = ref;
      const { payload } = ref;

      const action = { type, payload };
      const entry = this._actions[type];
      if (!entry) {
        if (true) {
          console.error((`[vuex] unknown action type: ${type}`));
        }
        return;
      }

      this._actionSubscribers.forEach((sub) => sub(action, this$1.state));

      return entry.length > 1
        ? Promise.all(entry.map((handler) => handler(payload)))
        : entry[0](payload);
    };

    Store.prototype.subscribe = function subscribe(fn) {
      return genericSubscribe(fn, this._subscribers);
    };

    Store.prototype.subscribeAction = function subscribeAction(fn) {
      return genericSubscribe(fn, this._actionSubscribers);
    };

    Store.prototype.watch = function watch(getter, cb, options) {
      const this$1 = this;

      if (true) {
        assert(typeof getter === 'function', 'store.watch only accepts a function.');
      }
      return this._watcherVM.$watch(() => getter(this$1.state, this$1.getters), cb, options);
    };

    Store.prototype.replaceState = function replaceState(state) {
      const this$1 = this;

      this._withCommit(() => {
        this$1._vm._data.$$state = state;
      });
    };

    Store.prototype.registerModule = function registerModule(path, rawModule, options) {
      if (options === void 0) options = {};

      if (typeof path === 'string') { path = [path]; }

      if (true) {
        assert(Array.isArray(path), 'module path must be a string or an Array.');
        assert(path.length > 0, 'cannot register the root module by using registerModule.');
      }

      this._modules.register(path, rawModule);
      installModule(this, this.state, path, this._modules.get(path), options.preserveState);
      // reset store to update getters...
      resetStoreVM(this, this.state);
    };

    Store.prototype.unregisterModule = function unregisterModule(path) {
      const this$1 = this;

      if (typeof path === 'string') { path = [path]; }

      if (true) {
        assert(Array.isArray(path), 'module path must be a string or an Array.');
      }

      this._modules.unregister(path);
      this._withCommit(() => {
        const parentState = getNestedState(this$1.state, path.slice(0, -1));
        Vue.delete(parentState, path[path.length - 1]);
      });
      resetStore(this);
    };

    Store.prototype.hotUpdate = function hotUpdate(newOptions) {
      this._modules.update(newOptions);
      resetStore(this, true);
    };

    Store.prototype._withCommit = function _withCommit(fn) {
      const committing = this._committing;
      this._committing = true;
      fn();
      this._committing = committing;
    };

    Object.defineProperties(Store.prototype, prototypeAccessors);

    function genericSubscribe(fn, subs) {
      if (subs.indexOf(fn) < 0) {
        subs.push(fn);
      }
      return function () {
        const i = subs.indexOf(fn);
        if (i > -1) {
          subs.splice(i, 1);
        }
      };
    }

    function resetStore(store, hot) {
      store._actions = Object.create(null);
      store._mutations = Object.create(null);
      store._wrappedGetters = Object.create(null);
      store._modulesNamespaceMap = Object.create(null);
      const { state } = store;
      // init all modules
      installModule(store, state, [], store._modules.root, true);
      // reset vm
      resetStoreVM(store, state, hot);
    }

    function resetStoreVM(store, state, hot) {
      const oldVm = store._vm;

      // bind store public getters
      store.getters = {};
      const wrappedGetters = store._wrappedGetters;
      const computed = {};
      forEachValue(wrappedGetters, (fn, key) => {
        // use computed to leverage its lazy-caching mechanism
        computed[key] = function () { return fn(store); };
        Object.defineProperty(store.getters, key, {
          get() { return store._vm[key]; },
          enumerable: true, // for local getters
        });
      });

      // use a Vue instance to store the state tree
      // suppress warnings just in case the user has added
      // some funky global mixins
      const { silent } = Vue.config;
      Vue.config.silent = true;
      store._vm = new Vue({
        data: {
          $$state: state,
        },
        computed,
      });
      Vue.config.silent = silent;

      // enable strict mode for new vm
      if (store.strict) {
        enableStrictMode(store);
      }

      if (oldVm) {
        if (hot) {
          // dispatch changes in all subscribed watchers
          // to force getter re-evaluation for hot reloading.
          store._withCommit(() => {
            oldVm._data.$$state = null;
          });
        }
        Vue.nextTick(() => oldVm.$destroy());
      }
    }

    function installModule(store, rootState, path, module, hot) {
      const isRoot = !path.length;
      const namespace = store._modules.getNamespace(path);

      // register in namespace map
      if (module.namespaced) {
        store._modulesNamespaceMap[namespace] = module;
      }

      // set state
      if (!isRoot && !hot) {
        const parentState = getNestedState(rootState, path.slice(0, -1));
        const moduleName = path[path.length - 1];
        store._withCommit(() => {
          Vue.set(parentState, moduleName, module.state);
        });
      }

      const local = module.context = makeLocalContext(store, namespace, path);

      module.forEachMutation((mutation, key) => {
        const namespacedType = namespace + key;
        registerMutation(store, namespacedType, mutation, local);
      });

      module.forEachAction((action, key) => {
        const type = action.root ? key : namespace + key;
        const handler = action.handler || action;
        registerAction(store, type, handler, local);
      });

      module.forEachGetter((getter, key) => {
        const namespacedType = namespace + key;
        registerGetter(store, namespacedType, getter, local);
      });

      module.forEachChild((child, key) => {
        installModule(store, rootState, path.concat(key), child, hot);
      });
    }

    /**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
    function makeLocalContext(store, namespace, path) {
      const noNamespace = namespace === '';

      const local = {
        dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
          const args = unifyObjectStyle(_type, _payload, _options);
          const { payload } = args;
          const { options } = args;
          let { type } = args;

          if (!options || !options.root) {
            type = namespace + type;
            if (true && !store._actions[type]) {
              console.error((`[vuex] unknown local action type: ${args.type}, global type: ${type}`));
              return;
            }
          }

          return store.dispatch(type, payload);
        },

        commit: noNamespace ? store.commit : function (_type, _payload, _options) {
          const args = unifyObjectStyle(_type, _payload, _options);
          const { payload } = args;
          const { options } = args;
          let { type } = args;

          if (!options || !options.root) {
            type = namespace + type;
            if (true && !store._mutations[type]) {
              console.error((`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`));
              return;
            }
          }

          store.commit(type, payload, options);
        },
      };

      // getters and state object must be gotten lazily
      // because they will be changed by vm update
      Object.defineProperties(local, {
        getters: {
          get: noNamespace
            ? function () { return store.getters; }
            : function () { return makeLocalGetters(store, namespace); },
        },
        state: {
          get() { return getNestedState(store.state, path); },
        },
      });

      return local;
    }

    function makeLocalGetters(store, namespace) {
      const gettersProxy = {};

      const splitPos = namespace.length;
      Object.keys(store.getters).forEach((type) => {
        // skip if the target getter is not match this namespace
        if (type.slice(0, splitPos) !== namespace) { return; }

        // extract local getter type
        const localType = type.slice(splitPos);

        // Add a port to the getters proxy.
        // Define as getter property because
        // we do not want to evaluate the getters in this time.
        Object.defineProperty(gettersProxy, localType, {
          get() { return store.getters[type]; },
          enumerable: true,
        });
      });

      return gettersProxy;
    }

    function registerMutation(store, type, handler, local) {
      const entry = store._mutations[type] || (store._mutations[type] = []);
      entry.push((payload) => {
        handler.call(store, local.state, payload);
      });
    }

    function registerAction(store, type, handler, local) {
      const entry = store._actions[type] || (store._actions[type] = []);
      entry.push((payload, cb) => {
        let res = handler.call(store, {
          dispatch: local.dispatch,
          commit: local.commit,
          getters: local.getters,
          state: local.state,
          rootGetters: store.getters,
          rootState: store.state,
        }, payload, cb);
        if (!isPromise(res)) {
          res = Promise.resolve(res);
        }
        if (store._devtoolHook) {
          return res.catch((err) => {
            store._devtoolHook.emit('vuex:error', err);
            throw err;
          });
        }
        return res;
      });
    }

    function registerGetter(store, type, rawGetter, local) {
      if (store._wrappedGetters[type]) {
        if (true) {
          console.error((`[vuex] duplicate getter key: ${type}`));
        }
        return;
      }
      store._wrappedGetters[type] = function wrappedGetter(store) {
        return rawGetter(
          local.state, // local state
          local.getters, // local getters
          store.state, // root state
          store.getters, // root getters
        );
      };
    }

    function enableStrictMode(store) {
      store._vm.$watch(function () { return this._data.$$state; }, () => {
        if (true) {
          assert(store._committing, 'Do not mutate vuex store state outside mutation handlers.');
        }
      }, { deep: true, sync: true });
    }

    function getNestedState(state, path) {
      return path.length
        ? path.reduce((state, key) => state[key], state)
        : state;
    }

    function unifyObjectStyle(type, payload, options) {
      if (isObject(type) && type.type) {
        options = payload;
        payload = type;
        type = type.type;
      }

      if (true) {
        assert(typeof type === 'string', (`Expects string as the type, but found ${typeof type}.`));
      }

      return { type, payload, options };
    }

    function install(_Vue) {
      if (Vue && _Vue === Vue) {
        if (true) {
          console.error(
            '[vuex] already installed. Vue.use(Vuex) should be called only once.',
          );
        }
        return;
      }
      Vue = _Vue;
      applyMixin(Vue);
    }

    var mapState = normalizeNamespace((namespace, states) => {
      const res = {};
      normalizeMap(states).forEach((ref) => {
        const { key } = ref;
        const { val } = ref;

        res[key] = function mappedState() {
          let { state } = this.$store;
          let { getters } = this.$store;
          if (namespace) {
            const module = getModuleByNamespace(this.$store, 'mapState', namespace);
            if (!module) {
              return;
            }
            state = module.context.state;
            getters = module.context.getters;
          }
          return typeof val === 'function'
            ? val.call(this, state, getters)
            : state[val];
        };
        // mark vuex getter for devtools
        res[key].vuex = true;
      });
      return res;
    });

    var mapMutations = normalizeNamespace((namespace, mutations) => {
      const res = {};
      normalizeMap(mutations).forEach((ref) => {
        const { key } = ref;
        const { val } = ref;

        res[key] = function mappedMutation() {
          const args = []; let
            len = arguments.length;
          while (len--) args[len] = arguments[len];

          let { commit } = this.$store;
          if (namespace) {
            const module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
            if (!module) {
              return;
            }
            commit = module.context.commit;
          }
          return typeof val === 'function'
            ? val.apply(this, [commit].concat(args))
            : commit.apply(this.$store, [val].concat(args));
        };
      });
      return res;
    });

    var mapGetters = normalizeNamespace((namespace, getters) => {
      const res = {};
      normalizeMap(getters).forEach((ref) => {
        const { key } = ref;
        let { val } = ref;

        val = namespace + val;
        res[key] = function mappedGetter() {
          if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
            return;
          }
          if (true && !(val in this.$store.getters)) {
            console.error((`[vuex] unknown getter: ${val}`));
            return;
          }
          return this.$store.getters[val];
        };
        // mark vuex getter for devtools
        res[key].vuex = true;
      });
      return res;
    });

    var mapActions = normalizeNamespace((namespace, actions) => {
      const res = {};
      normalizeMap(actions).forEach((ref) => {
        const { key } = ref;
        const { val } = ref;

        res[key] = function mappedAction() {
          const args = []; let
            len = arguments.length;
          while (len--) args[len] = arguments[len];

          let { dispatch } = this.$store;
          if (namespace) {
            const module = getModuleByNamespace(this.$store, 'mapActions', namespace);
            if (!module) {
              return;
            }
            dispatch = module.context.dispatch;
          }
          return typeof val === 'function'
            ? val.apply(this, [dispatch].concat(args))
            : dispatch.apply(this.$store, [val].concat(args));
        };
      });
      return res;
    });

    var createNamespacedHelpers = function (namespace) {
      return ({
        mapState: mapState.bind(null, namespace),
        mapGetters: mapGetters.bind(null, namespace),
        mapMutations: mapMutations.bind(null, namespace),
        mapActions: mapActions.bind(null, namespace),
      });
    };

    function normalizeMap(map) {
      return Array.isArray(map)
        ? map.map((key) => ({ key, val: key }))
        : Object.keys(map).map((key) => ({ key, val: map[key] }));
    }

    function normalizeNamespace(fn) {
      return function (namespace, map) {
        if (typeof namespace !== 'string') {
          map = namespace;
          namespace = '';
        } else if (namespace.charAt(namespace.length - 1) !== '/') {
          namespace += '/';
        }
        return fn(namespace, map);
      };
    }

    function getModuleByNamespace(store, helper, namespace) {
      const module = store._modulesNamespaceMap[namespace];
      if (true && !module) {
        console.error((`[vuex] module namespace not found in ${helper}(): ${namespace}`));
      }
      return module;
    }

    const index_esm = {
      Store,
      install,
      version: '3.0.1',
      mapState,
      mapMutations,
      mapGetters,
      mapActions,
      createNamespacedHelpers,
    };


    /* harmony default export */ __webpack_exports__.default = (index_esm);
    /** */ }),

  /** */ './node_modules/webpack/buildin/global.js':
  /*! ***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \********************************** */
  /*! no static exports found */
  /** */ (function (module, exports) {
    let g;

    // This works in non-strict mode
    g = (function () {
      return this;
    }());

    try {
      // This works if eval is allowed (see CSP)
      g = g || new Function('return this')();
    } catch (e) {
      // This works if the window reference is available
      if (typeof window === 'object') g = window;
    }

    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}

    module.exports = g;
    /** */ }),

}]);
// # sourceMappingURL=../../.sourcemap/mp-weixin/common/vendor.js.map
